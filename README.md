# Робота в командному рядку Linux

## Зміст

- [Введення](#Введення)
  - [Що таке bash](#що-таке-bash>)
- [Команди](#Команди)
  - [Команди `cd`, `pwd`, `ls`](#команди-cd-pwd-ls)
  - [Команди `mkdir`, `touch`, `echo`, `cp`, `mv`, `rm`](#команди-mkdir-touch-echo-cp-mv-rm)
  <!-- - [Перенаправлення вводу-виводу](#) -->
  - [Жорсткі посилання](#жорсткі-посилання)
  - [Символічні посилання](#символічні-посилання>)
  - [Використання wildcards](#використання-wildcards)
  - [Команди find і grep](#команди-find-і-grep)
  - [Команда man](#команда-man)
- [Текстові редактори](#text-editors)
  - [vim](#vim)
  - [nano](#nano)
- [Змінні середовища](#environment-variables)
  - [PATH](#path)
- [Профіль користувача, групи, права доступу](#user-profile-permissions)
  - [chmod](#chmod)
  - [foreground і background процеси](#foreground-background)
  - [Сигнали і команда kill](#signals-kill)
- [Shell скрипти](#shell-scripts)
  - [Запуск Python скриптів](#for-loops)
  - [Конструкція створення циклів "for"](##for-loops)
  - [Арифметика в shell](#arithmetic-shell)
  <!-- - [Команда–переключатель "case"](##case-switch) -->
- [Таблиці команд](#command-tables)
  - [bash](#bash)
  - [Клавіатура vim](#vim-keyboard)
  - [Клавіатура nano](#nano-keyboard)
- [Завдання](#assignments)

## Введення

Інтерфейс командного рядка комп'ютера надає нам тісний
зв'язок з операційною системою (ОС). Командний рядок містить
величезну кількість функцій, відточених і відшліфованих за
десятиліття використання.

### Що таке bash

Bash (акронім від "Bourne-again SHell") — це стандартний інтерпретатор команд на більшості систем Linux. В його обов'язки входить обробка та виконання команд, за допомогою яких користувач керує комп'ютером.

<!-- Після того як ви завершили роботу, можна закінчити процес командного інтерпретатора. Після натискання клавіш `Ctrl–D`, команди `exit` або `logout`, процес командного інтерпретатора буде завершено, і на екрані знову з'явиться запрошення ввести ім'я користувача та пароль. -->

## Команди

Кожна виконувана програма «працює» у строго визначеній
директорії файлової системи. Така директорія називається
поточною директорією; можна уявити, що програма під час
роботи «перебуває» саме в цій директорії — це її «робоче
місце». В залежності від поточної директорії може змінюватися
поведінка програми: часто програма за замовчуванням
працюватиме з файлами, розташованими саме в поточній
директорії — до них вона «дотягнеться» в першу чергу. Поточна
директорія є у будь-якої програми, в тому числі й у командної
оболонки користувача. Оскільки взаємодія користувача з
системою обов'язково опосередкована командною оболонкою,
можна говорити про те, що користувач «перебуває» в тій
директорії, яка в даний момент є поточною директорією його
командної оболонки.

Розглянемо різні команди, які можна виконувати в bash.

## Команди `cd`, `pwd`, `ls`

#### `cd` і директорії

Почнемо використовувати bash для навігації по файловій
системі. Для початку наберіть наступну команду:

```bash
cd /
```

_change directory_

У наведеному вище прикладі `/` (аргумент команди `cd`)
називається шляхом. Це місце файлової системи, куди ми
хочемо переміститися. Команда `cd` використовується для
зміни поточної робочої директорії.

Усі директорії в системі організовані в деревоподібну
структуру, і `/` — це її початок (або корінь). У цьому
випадку `/` — абсолютний шлях, це означає, що шлях вказаний
відносно кореневої директорії.

<!-- TODO: додати приклад дерева каталогів  -->

Щоб дізнатися, в якому місці файлової системи ви зараз перебуваєте (поточна робоча директорія), наберіть:

```bash
pwd
```

_print working directory_

#### Абсолютні шляхи

Ось кілька прикладів абсолютних шляхів:

```
/dev
/usr
/usr/bin
/usr/local/bin
```

Усі ці шляхи об'єднує те, що вони починаються з `/`.
Вказуючи шлях `/usr/local/bin` в якості аргументу команді
`cd`, ми говоримо їй перейти до кореневої директорії `/`,
потім до директорії `usr`, далі до `local` і `bin`.
Абсолютні шляхи завжди починаються з `/`.

#### Відносні шляхи

Другий вид шляхів називається відносними. Bash, команда `cd` та інші команди
відраховують ці шляхи відносно поточної директорії. Відносні
шляхи ніколи не починаються з `/`. Наприклад, якщо ми
знаходимося в `/usr` (`cd /usr`), ми можемо перейти в `/usr/
local/bin`, використовуючи відносний шлях:

```bash
cd local/bin
pwd
# /usr/local/bin
```

#### Використання "\.\."

Директорія `..` вказує на батьківську директорію відносно нашої робочої директорії. Приклад:

```bash
pwd
# /usr/local/bin
cd ..
pwd
# /usr/local
```

Команда `cd ..` «піднімає на рівень вище». Можна додати `..`
до відносного шляху. Це дозволить переміститися в
директорію, яка знаходиться на одному рівні з тією, яка є
робочою. Приклад:

```bash
pwd
# /usr/local
cd ../share
pwd
# /usr/share
```

#### Приклади з використанням відносних шляхів

Відносні шляхи можуть бути досить складними. Ось кілька
прикладів. Результат виконання команд не показаний,
спробуйте визначити, в якій директорії ви опинитеся,
використовуючи bash.

```bash
cd /bin
cd ../usr/share/zoneinfo

cd /usr/lib/debug/lib
cd ../usr/lib

cd /usr/bin
cd ../bin/../bin
```

#### Робоча директорія "\."

Перед тим як завершити розгляд команди `cd`, слід згадати,
що існує ще одна спеціальна директорія `.` (точка), яка
вказує на поточну директорію. Ця директорія використовується
для запуску виконуваних файлів, що знаходяться в поточній
директорії.

```bash
./myprog
```

У останньому прикладі `myprog` — це виконуваний файл, що
знаходиться в поточній директорії, який буде запущено на
виконання.

#### `cd` і домашня директорія користувача

Щоб перейти до домашньої директорії, потрібно ввести:

```bash
cd
```

або

```bash
cd ~
```

Без аргументів команда `cd` зробить домашню директорію
поточною. Тильда `~` — спеціальне ім'я, яке в bash вказує на
домашню директорію користувача. Для суперкористувача
домашньою зазвичай є директорія `/root` (або `/var/root/` на
macOS), а для звичайних користувачів — `/home/<username>/`
(або `/Users/<username>/` на macOS).

Якщо потрібно вказати конкретний файл, що знаходиться в
домашній директорії, то можна написати:

```bash
./myprog /home/user/myfile.txt
```

Використовувати абсолютні шляхи до файлів не завжди зручно.
Цю ж операцію можна виконати за допомогою тильди `~`:

```bash
./myprog ~/myfile.txt
```

#### `ls`

Команда `ls`, викликана без аргументів, виводить на екран список файлів, що зберігаються в робочій директорії:

```bash
$ cd /usr
$ ls
X11R6      doc         i686-pc-linux-gnu  lib      man          sbin   ssl
bin        gentoo-x86  include            libexec  portage      share  tmp
distfiles  i686-linux  info               local    portage.old  src
```

Якщо вказати опцію `-a`, можна буде побачити всі файли, включаючи приховані (імена яких починаються з точки).

```bash
$ ls -a
.      bin        gentoo-x86         include  libexec  portage      share  tmp
..     distfiles  i686-linux         info     local    portage.old  src
X11R6  doc        i686-pc-linux-gnu  lib      man      sbin         ssl
```

Після команди `ls` в якості її аргументу можна вказати один або більше файлів або директорій. Якщо вказати ім'я файлу, команда `ls` виведе інформацію лише про цей файл. Якщо вказати назву директорії, `ls` покаже все її вміст.

Опція `-l` команди `ls` дуже корисна, якщо потрібно, окрім імен файлів, дізнатися більш детальну інформацію про них (права на файл, ім'я власника, час останньої зміни файлу і його розмір). Додавання опції `-t` сортує файли за датою останньої зміни, а `-r` — сортує результати у зворотному порядку. У наступному прикладі показано застосування опції `-l` для виводу інформації про файли, що зберігаються в директорії `/usr`:

```bash
$ ls -l /usr
drwxr-xr-x    7 root     root          168 Nov 24 14:02 X11R6
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 bin
drwxr-xr-x    2 root     root         8856 Dec 26 12:47 distfiles
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 doc -> share/doc
drwxr-xr-x   62 root     root         1856 Dec 27 15:54 gentoo-x86
drwxr-xr-x    4 root     root          152 Dec 12 23:10 i686-linux
drwxr-xr-x    4 root     root           96 Nov 24 13:17 i686-pc-linux-gnu
drwxr-xr-x   54 root     root         5992 Dec 24 22:30 include
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 info -> share/info
drwxr-xr-x   28 root     root        13552 Dec 26 00:31 lib
drwxr-xr-x    3 root     root           72 Nov 25 00:34 libexec
drwxr-xr-x    8 root     root          240 Dec 22 20:57 local
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 man -> share/man
lrwxrwxrwx    1 root     root           11 Dec  8 07:59 portage -> gentoo-x86/
drwxr-xr-x   60 root     root         1864 Dec  8 07:55 portage.old
drwxr-xr-x    3 root     root         3096 Dec 22 20:57 sbin
drwxr-xr-x   46 root     root         1144 Dec 24 15:32 share
drwxr-xr-x    8 root     root          328 Dec 26 00:07 src
drwxr-xr-x    6 root     root          176 Nov 24 14:25 ssl
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 tmp -> ../var/tmp
```

У першій колонці показана інформація про права доступу до кожного файлу в списку. Наступна колонка показує кількість посилань на кожен елемент списку. Третя та четверта колонки — власник і група файлу відповідно. П’ята колонка — розмір. Шоста — час останньої зміни файлу (модифікації). Остання колонка — ім'я файлу або директорії (якщо це посилання, то після знака `->` стоїть ім'я об'єкта, на який воно посилається).

Іноді виникає потреба подивитися інформацію лише про директорії, а не про все їх вміст. Для цього потрібно скористатися опцією `-d`, яка вказує команді виводити інформацію лише про директорії. Приклад:

```bash
$ ls -dl /usr /usr/bin /usr/X11R6/bin ../share
drwxr-xr-x    4 root     root           96 Dec 18 18:17 ../share
drwxr-xr-x   17 root     root          576 Dec 24 09:03 /usr
drwxr-xr-x    2 root     root         3192 Dec 26 12:52 /usr/X11R6/bin
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 /usr/bin
```

Дія опції `-R` є протилежною дії `-d`. Вона дозволяє виводити інформацію про файли, що знаходяться в директорії рекурсивно. Спочатку показується вміст директорії верхнього рівня, потім по черзі вміст усіх піддиректорій і так далі. Вивід цієї команди може бути досить об'ємним, тому приклад не наводиться, але можна спробувати зробити це самостійно, набравши в командному рядку `ls -R` або `ls -Rl`.

І, нарешті, опція `-i` використовується для виводу inode кожного об'єкта файлової системи.

```bash
$ ls -i /usr
1409 X11R6        314258 i686-linux           43090 libexec        13394 sbin
1417 bin            1513 i686-pc-linux-gnu     5120 local          13408 share
8316 distfiles      1517 include                776 man            23779 src
43 doc            1386 info                 93892 portage        36737 ssl
70744 gentoo-x86     1585 lib                   5132 portage.old      784 tmp
```

Кожен об'єкт файлової системи (файл, директорія тощо) має свій унікальний номер, званий інодом (inode number). Ця інформація може здаватися незначною, але розуміння функції inode дозволяє розібратися у багатьох операціях над файловою системою. Наприклад, розглянемо `.` і `..` як посилання, присутні в кожній директорії. Щоб зрозуміти, що з себе представляє директорія `..`, дізнаємося inode директорії `/usr/local`:

```bash
$ ls -id /usr/local
5120 /usr/local
```

У цьому прикладі inode директорії `/usr/local` — `5120`. Тепер подивимося, який inode у директорії `/usr/local/bin/..`:

```bash
$ ls -id /usr/local/bin/..
5120 /usr/local/bin/..
```

Виходить, що inode директорій `/usr/local` і `/usr/local/bin/..` збігаються. Це означає, що на inode `5120` посилаються два імені: `/usr/local` і `/usr/local/bin/..`. Тобто це два різних імені однієї директорії. Кожен inode вказує на певне місце на диску. З кожним inode може бути пов'язано кілька імен об'єктів файлової системи. Кількість «синонімів» файлу (об'єктів файлової системи, що посилаються на один inode) показує число у другому стовпці виводу команди `ls -l`:

```bash
$ ls -dl /usr/local
drwxr-xr-x    8 root     root          240 Dec 22 20:57 /usr/local
```

У цьому прикладі видно (другий стовпець), що на директорію `/usr/local` посилаються 8 різних об'єктів. Ось
їх імена:

```
/usr/local
/usr/local/.
/usr/local/bin/..
/usr/local/games/..
/usr/local/lib/..
/usr/local/sbin/..
/usr/local/share/..
/usr/local/src/..
```

### Команди `mkdir`, `touch`, `echo`, `cp`, `mv`, `rm`

#### mkdir

Розглянемо команду `mkdir`. Вона слугує для створення нових директорій. У наступному прикладі демонструється створення трьох нових директорій (tic, tac, toe) у директорії `/tmp`:

```bash
$ cd /tmp
$ mkdir tic tac toe
```

За замовчуванням команда `mkdir` не може створити вкладену структуру директорій. Тому, якщо вам потрібно створити кілька вкладених директорій (наприклад, `won/der/ful`), доведеться тричі по черзі викликати цю команду:

```bash
$ mkdir won/der/ful
mkdir: cannot create directory 'won/der/ful': No such file or directory
$ mkdir won
$ mkdir won/der
$ mkdir won/der/ful
```

Упростити цю операцію можна, додавши опцію `-p` до команди `mkdir`. Ця опція дозволяє створювати вкладену структуру директорій:

```bash
$ mkdir -p easy/as/pie
```

Щоб дізнатися про можливості цієї утиліти детальніше, прочитайте довідку, яка викликається командою `man mkdir`. Довідки є практично до всіх команд, розглянутих у цій посібнику (наприклад, `man ls`), крім `cd`, оскільки вона вбудована в bash (для таких команд довідка викликається так: `help cd`).

#### `touch`

Перейдемo до вивчення команд `cp` та `mv`, які слугують для копіювання, перейменування та переміщення файлів і директорій. Але спочатку створимо пустий файл у директорії `/tmp` за допомогою команди `touch`:

```bash
$ cd /tmp
$ touch copyme
```

Команда `touch` оновлює час останнього доступу до файлу (шоста колонка виводу команди `ls -l`), якщо файл вже існує, або створює новий пустий файл, якщо його ще немає. Після цієї операції повинен з'явитися пустий файл `/tmp/copyme`.

#### Перенаправлення вводу-виводу

Тепер, коли у нас є пустий файл, запишемо в нього текстову строку за допомогою команди `echo`, яка виводить переданий їй аргумент на стандартне пристрій виводу (текстовий термінал у нашому випадку):

```bash
$ echo "firstfile"
firstfile
```

Щоб записати строку в наш файл, потрібно перенаправити в нього вивід команди `echo`:

```bash
$ echo "firstfile" > copyme
```

Знак `>` (більше) вказує командній оболонці, що потрібно перенаправити вивід команди
зліва в файл, ім'я якого знаходиться справа. Якщо файлу з таким ім'ям не існує,
він буде створений автоматично. А якщо такий файл вже є, то він буде перезаписаний
(усе його вміст буде стерто перед записом нашої строки). Команда `ls -l` покаже,
що розмір створеного файлу тепер становить 10 байт — дев'ять байт займає слово
'firstfile' і один байт символ зміни рядка (`\n` line feed).

```bash
$ ls -l copyme
-rw-r--r--    1 root     root           10 Dec 28 14:13 copyme
```

Для виводу вмісту файлу в термінал використовується команда `cat`:

```bash
$ cat copyme
firstfile
```

Вивід команди `cat` також можна перенаправити з екрану термінала в якийсь файл.
Команда:

 <!-- скориставшись символом перенаправлення вихідного потоку даних — знаком "більше" — `>` -->

```bash
$ cat copyme1 copyme2 ... copymeN > copyme
```

запише вміст усіх файлів, імена яких стоять перед знаком `>`, воєдино в «copyme» — конкатенує їх. Перенаправлення вихідних даних зі стандартного потоку виводу (екрана) у файл є стандартним для всіх команд, що виконуються командним інтерпретатором. Ви можете отримати файл, що містить список усіх файлів поточної директорії, якщо виконаєте команду:

```bash
$ ls -a > list.txt
```

Якщо імена вхідних файлів для команди `cat` не задані, то вона використовуватиме як вхідні дані інформацію, що вводиться з клавіатури, до тих пір, поки ви не наберете ознаку закінчення вводу — комбінацію клавіш <kbd>Ctrl+D</kbd>.

Отже, команда:

```bash
$ cat > copyme
```

дозволяє створити новий текстовий файл з ім'ям «copyme» і вмістом, яке користувач введе з клавіатури. У команди `cat` існує безліч різних опцій. Подивитися її повний опис можна за допомогою `man cat`.

Зверніть увагу, що поряд з перенаправленням вихідних даних існує спосіб перенаправити вхідні дані. Якщо під час виконання якоїсь команди потрібно ввести дані з клавіатури, можна покласти їх заздалегідь у файл, а потім перенаправити стандартний ввід цієї команди за допомогою знака "менше" — `<` і наступного за ним імені файлу з вхідними даними.

Перенаправлення за допомогою `>` перезаписує вміст файлу заново. Якщо потрібно дописати в кінець, слід скористатися `>>`.

Наприклад:

```bash
$ ls -a > list.txt
$ ls -a >> list.txt
```

Файл `list.txt` буде містити результат роботи обох запусків команди `ls`.

Для поетапного перегляду вмісту файлу можна використовувати команди `less` або `more`. Якщо потрібно вивести перші або останні рядки файлу, скористайтеся командами `head`/`tail`. Команда `head` виводить перші десять рядків файлу, а `tail` — останні десять. Кількість рядків задається за допомогою параметра `-n`.

Тепер розглянемо базову функціональність команди `cp`. Ця команда приймає два аргументи. Перший — ім'я вже існуючого файлу (`copyme`), другий — назва нової копії, яку потрібно створити (`copiedme`).

```bash
$ cp copyme copiedme
```

Нова копія файлу має інший номер inode (це означає, що був створений дійсно новий окремий файл, а не просто посилання на старий).

```bash
$ ls -i copyme copiedme
648284 copiedme   650704 copyme
```

Тепер застосуємо команду `mv`, щоб перейменувати файл ("copiedme" → "movedme"). Номер inode після цієї операції не змінюється, а змінюється лише назва файлу.

```bash
$ mv copiedme movedme
$ ls -i movedme
648284 movedme
```

Номер inode не змінюється лише за умови, що перейменований файл залишається в межах тієї файлової системи, де знаходився вихідний файл. Команда `mv` дозволяє не лише перейменовувати файли, але й переміщати їх. Наприклад, щоб перемістити файл `/var/tmp/myfile.txt` у директорію `/home/user`, потрібно дати команду:

```bash
$ mv /var/tmp/myfile.txt /home/user
```

Файл буде переміщений у домашню директорію користувача `user`, навіть якщо вона знаходиться в іншій файловій системі (в цьому випадку файл буде скопійований у нове місце, після чого оригінал буде видалений). Переміщення файлу в іншу файлову систему призводить до зміни його inode. Це відбувається, оскільки кожна файлова система має свій окремий набір inode. Варто зазначити, що існує ймовірність, що новий присвоєний номер inode може збігтися зі старим, але вона надзвичайно мала.

Щоб перемістити одночасно кілька файлів в одну директорію, потрібно написати:

```bash
$ mv /var/tmp/myfile1.txt /var/tmp/myfile2.txt /home/user
```

або

```bash
$ mv -t /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
```

Якщо додати опцію `-v`, на екран буде виведено звіт про виконану операцію:

```bash
$ mv -vt /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
'/var/tmp/myfile1.txt' -> '/home/user/myfile1.txt'
'/var/tmp/myfile2.txt' -> '/home/user/myfile2.txt'
```

### rm

Тепер, після ознайомлення з командами `cp`, `mv`, розглянемо, як видаляти файли.
Зазвичай видалення виконується за допомогою команди `rm`.
Щоб видалити кілька файлів, потрібно вказати їхні імена через пробіл у командному
рядку як аргументи до `rm`:

```bash
$ cd /tmp
$ touch file1 file2
$ ls -l file1 file2
-rw-r--r--    1 root     root            0 Jan  1 16:41 file1
-rw-r--r--    1 root     root            0 Jan  1 16:41 file2
$ rm file1 file2
$ ls -l file1 file2
ls: file1: No such file or directory
ls: file2: No such file or directory
```

Видалені файли неможливо відновити (хоча можна спробувати). Тому багато початківців у
Linux використовують опцію `-i` команди `rm`, яка запитує у користувача підтвердження
видалення кожного файлу.

```bash
$ rm -i file1 file2
rm: remove regular empty file `file1'? y
rm: remove regular empty file `file2'? y
```

У останньому прикладі перед видаленням кожного файлу команда `rm` запитує: чи дійсно
користувач хоче видалити файл? Щоб підтвердити видалення, потрібно натиснути клавішу <kbd>y</kbd> на клавіатурі, а щоб відмовитися — клавішу <kbd>n</kbd>. Прервати виконання будь-якої команди
(якщо щось пішло не так) можна, натиснувши комбінацію <kbd>Ctrl+C</kbd>. Щоб команда `rm`
запитувала підтвердження на видалення кожного файлу навіть без опції `-i`, можна додати
в файл `~/.bashrc` за допомогою улюбленого текстового редактора рядок:

```bash
alias rm="rm -i"
```

### `rmdir`

Є два способи видалення директорій: можна поетапно видалити все вміст директорії, а потім використати команду `rmdir` для видалення самої директорії:

```bash
$ mkdir mydir
$ touch mydir/file1
$ rm mydir/file1
$ rmdir mydir
```

Цей спосіб зазвичай називають "метод видалення директорій для невдах". Набагато зручніше використовувати команду `rm -rf` для видалення директорії з усім її вмістом.

```bash
$ rm -rf mydir
```

Цю команду потрібно використовувати з обережністю, оскільки за її допомогою адміністратору (тим більше з правами адміністратора) без досвіду дуже легко видалити вміст з усього жорсткого диска.

### Жорсткі посилання

Слово "посилання" вже згадувалося, коли розглядалися директорії та inode. Насправді в Linux існує два види посилань. Перший вид називають жорсткими посиланнями. Кожен inode може мати кілька пов’язаних з ним жорстких посилань. Таким чином, файл може існувати в системі під кількома різними іменами. Файл існує доти, поки з його inode пов’язане хоча б одне ім’я. Поняття «жорстке посилання на файл» і «ім’я файлу» є синонімами. Нові жорсткі посилання на файл можна створити за допомогою команди `ln`:

```bash
$ cd /tmp
$ touch firstlink
$ ln firstlink secondlink
$ ls -i firstlink secondlink
15782 firstlink    15782 secondlink
```

Як видно з прикладу, жорсткі посилання працюють на рівні inode, вказуючи на певний файл. В Linux у жорстких посилань є кілька обмежень. По-перше, можна створювати жорсткі посилання лише на файли, а не на директорії. Хоча в системі існують жорсткі посилання на директорії (`.` і `..`), навіть суперкористувач не може створювати додаткові жорсткі посилання на директорії. По-друге, неможливо створити жорстке посилання на файл, що знаходиться в іншій файловій системі, оскільки кожна файлові система має свій унікальний набір inode.

### Символічні посилання

На практиці частіше використовують символічні посилання (або симлінки). Симлінк — це спеціальний вид файлу, який посилається на інший файл за його іменем, а не безпосередньо на inode. Симлінки не захищають файл від видалення. Якщо файл видалити, то симлінк на нього стане неробочим (або "битим"). Симлінки створюються командою `ln` з опцією `-s`:

```bash
$ ln -s secondlink thirdlink
$ ls -l firstlink secondlink thirdlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 firstlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 secondlink
lrwxrwxrwx    1 agriffis agriffis       10 Dec 31 19:39 thirdlink -> secondlink
```

Символічне посилання можна розпізнати за виводом команди `ls -l`: по-перше, в першій колонці для симлінків стоїть буква 'l' (перша буква англійського слова "link"); по-друге, розмір симлінка дорівнює кількості букв в імені файлу, на який він посилається (в нашому випадку — `secondlink`); по-третє, в останній колонці, окрім імені посилання, міститься ім'я файлу, на який воно посилається, після знака `->`.

Символічні посилання значно гнучкіші за жорсткі. З їх допомогою можна посилатися на будь-який об'єкт (файл, директорію, сокет тощо) будь-якої файлової системи.

Розглянемо ситуацію, коли потрібно зробити симлінк, який вказує на `/usr/local/bin` і знаходиться в директорії `/tmp/`:

```bash
$ ln -s /usr/local/bin bin1
$ ls -l bin1
lrwxrwxrwx    1 root     root           14 Jan  1 15:42 bin1 -> /usr/local/bin
```

Або

```bash
$ ln -s ../usr/local/bin bin2
$ ls -l bin2
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin
```

Як видно з цих прикладів, обидва посилання вказують на одну директорію. Але якщо друге посилання перемістити з `/tmp` в іншу директорію, воно може стати "битим" через використаний у ньому відносний шлях:

```bash
$ ls -l bin2
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin
$ mkdir mynewdir
$ mv bin2 mynewdir
$ cd mynewdir
$ cd bin2
bash: cd: bin2: No such file or directory
```

Оскільки не існує директорії `/tmp/usr/local/bin/`, неможливо перейти в робочу директорію `bin2;` іншими словами, після переміщення посилання перестало працювати (стало "битим"). Через це іноді варто уникати створення симлінків з використанням відносних шляхів. Але іноді це може бути зручним.

Розглянемо приклад, коли потрібно зробити посилання на програму в `/usr/bin` (тобто надати цій програмі альтернативну назву):

```
# ls -l /usr/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
```

Суперкористувач (root) може захотіти зробити посилання на програму "keychain" з більш коротким ім'ям "kc". У цьому прикладі у нас є root-доступ до системи, про що свідчить запрошення bash, що змінилося на "#". Права суперкористувача також потрібні, оскільки звичайні користувачі не можуть створювати файли в директорії `/usr/bin/`. Тепер можна від імені root створити альтернативне ім'я для `keychain`:

```
# cd /usr/bin
# ln -s /usr/bin/keychain kc
# ls -l keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
# ls -l kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain
```

У цьому прикладі було створено симлінк `kc`, який посилається на файл `/usr/bin/keychain`. Це посилання повністю робоче, але вонo перестане працювати, якщо перемістити обидва файли `keychain` і `kc` з директорії `/usr/bin/` в `/usr/local/bin/`:

```
# mv /usr/bin/keychain /usr/bin/kc /usr/local/bin
# ls -l /usr/local/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# ls -l /usr/local/bin/kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain
```

Оскільки при створенні посилання був використаний абсолютний шлях, воно продовжує вказувати на файл `/usr/bin/keychain`, якого більше немає. Але якщо б використовувався відносний шлях при створенні посилання, воно залишилося б робочим.

Таким чином, посилання, створені з абсолютними і відносними шляхами, мають своє застосування. Тому при створенні симлінка потрібно вибрати спосіб, який буде доцільнішим у даній ситуації. Часто обидва види симлінків (з абсолютними і відносними шляхами) працюють нормально. Наступний приклад демонструє спосіб створення симлінка, який продовжує працювати після переміщення його та файлу, на який він посилається, в іншу директорію:

```
# cd /usr/bin
# ln -s keychain kc
# ls -l kc
lrwxrwxrwx    1 root     root            8 Jan  5 12:40 kc -> keychain
# mv keychain kc /usr/local/bin
# ls -l /usr/local/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# ls -l /usr/local/bin/kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> keychain
```

Тепер можна запускати програму `keychain`, звертаючись до неї за іменем `/usr/local/bin/kc`.

### Використання шаблонів (wildcards)

У повсякденному використанні часто виникають ситуації, коли потрібно виконати одну просту операцію (наприклад, `rm`) над багатьма файлами. У такому випадку не дуже зручно перераховувати всі імена файлів у командному рядку:

```bash
$ rm file1 file2 file3 file4 file5 file6 file7 file8
```

Цю проблему можна вирішити за допомогою шаблонів заміни (wildcards). Командний інтерпретатор підтримує можливість вказання кількох файлів, використовуючи шаблони (з історичних причин це також називають "globbing"). Bash і інші команди вибирають лише ті файли, які збігаються з шаблоном.

Наприклад, якщо потрібно видалити файли з `file1` по `file8`, можна написати:

```bash
$ rm file[1-8]
```

А якщо потрібно видалити всі файли, імена яких починаються зі слова `file`, можна використовувати:

```bash
$ rm file*
```

Шаблон `*` відповідає будь-якому символу, послідовності символів або "відсутності символу". Звичайно, шаблони можна застосовувати не лише для видалення файлів, як буде показано нижче.

Якщо необхідно вивести список файлів у директорії `/etc/`, імена яких починаються з літери "g" (і файл з ім'ям "g", якщо такий існує), потрібно написати:

```bash
$ ls -d /etc/g*
```

Це може вивести щось на кшталт:

```
/etc/gconf  /etc/ggi  /etc/gimp  /etc/gnome  /etc/gnome-vfs-mime-magic  /etc/gpm  /etc/group  /etc/group-
```

Давайте подивимося, що станеться, якщо вказати шаблон, який не збігається з жодним іменем файлу:

```bash
$ ls -d /usr/bin/asdf*jkl
ls: /usr/bin/asdf*jkl: No such file or directory
```

У цьому прикладі ми намагалися вивести список файлів, імена яких починаються на "asdf" і закінчуються на "jkl". Командний інтерпретатор видав повідомлення, що файлів з такими іменами не знайдено.

#### Синтаксис шаблона: `*` і `?`

Ми розглянули, як працює глоббінг (підстановка імен файлів). Тепер розглянемо детальніше синтаксис шаблонів:

- **`*`** відповідає нулю або більшій кількості символів:
  - `/etc/g*` — всі файли в директорії `/etc/`, імена яких починаються з "g" (включаючи файл з ім'ям "g").
  - `/tmp/my*1` — всі файли в директорії `/tmp/`, імена яких починаються з "my" і закінчуються на "1" (включаючи файл з ім'ям "my1").

- **`?`** замінює один будь-який символ:
  - `myfile?` — будь-який файл, чиє ім'я починається зі слова "myfile", за яким слідує один будь-який символ.
  - `/tmp/notes?txt` — відповідає файлам з іменами "notes.txt" та "notes_txt" (якщо вони існують у `/tmp/`).

Ці шаблони дозволяють зручно працювати з групами файлів, спрощуючи виконання команд.

#### Квадратні дужки: `[]`

Шаблон `[]` дуже схожий на `?`, але дозволяє явно вказувати набір символів. Шаблон `[]` відповідає одному символу з тих, що вказані в дужках. Також у дужках можна вказувати діапазон символів (для цього використовується символ дефісу), або кілька діапазонів підряд. Тоді шаблон буде відповідати будь-якому символу з цього діапазону:

- `myfile[12]` — відповідає `myfile1` і `myfile2`. Шаблон буде працювати, поки існує хоча б один з цих двох файлів.
- `[Cc]hange[Ll]og` — відповідає файлам з іменами `Changelog`, `ChangeLog`, `changeLog` і `changelog`. Як ви могли помітити, використання шаблону `[]` корисно при пошуку імен, що відрізняються регістром букв.

Декілька прикладів використання шаблонів:

- `ls /etc/[0-9]*` — виведе список файлів у директорії `/etc/`, імена яких починаються з цифри.
- `ls /tmp/[A-Za-z]*` — виведе список файлів у директорії `/tmp/`, імена яких починаються з букви (велика або мала).

Конструкція `[[]]` схожа на `[]`, за винятком того, що вона відповідає одиничному символу, не згаданому між `[[` і `]`. Наприклад:

```bash
rm myfile[[9]
```

Ця команда видалить всі файли, імена яких складаються зі слова "myfile" і однієї цифри, за винятком файлу "myfile9".

Розглянемо декілька прикладів використання шаблонів.
Оскільки `bash` інтерпретує символи `?`, `[`, `]`, `*` як шаблони заміни, потрібно бути обережним при використанні аргументів, що містять ці символи. Наприклад, якщо ви хочете створити файл, що містить рядок `[fo]*`, то така команда може зробити не те, що ви очікуєте:

```bash
$ echo [fo]* > /tmp/mynewfile.txt
```

Якщо в робочій директорії знайдеться один або кілька файлів, імена яких відповідають шаблону `[fo]*`, то в `/tmp/mynewfile.txt` буде список їхніх імен, а не рядок `[fo]*`.

Існує кілька способів записати цей рядок у файл:

1. Використати одинарні лапки:

   ```bash
   $ echo '[fo]*' > /tmp/mynewfile.txt
   ```

   Після виконання цієї команди файл буде містити рядок `[fo]*`, як і очікувалося.

2. "Екранувати" спеціальні символи за допомогою зворотного слеша (`\`):

   ```bash
   $ echo \[fo\]\* > /tmp/mynewfile.txt
   ```

Обидва запропоновані методи (одинарні лапки і екранування) дають бажаний результат. Щоб вказати текстовий символ `"`, можна або взяти його в одинарні лапки, або написати `\"`.

**Застереження:** Подвійні лапки працюють майже так само, як і одинарні, але дозволяють `bash` інтерпретувати деякі спеціальні символи. Тому одинарні лапки — найкращий спосіб передати команді лише текст. Для додаткової інформації про шаблони читайте справку `man 7 glob`. Для додаткової інформації про використання лапок, читайте розділ QUOTING справки `man 8 glob`.

### Команди `find` і `grep`

#### `find`

Для пошуку файлів і каталогів використовується команда `find`. 

_Пошук за назвою._
Для того щоб знайти файл `views.py`, який розташований десь під
директорією `./my-first-blog` достатньо ввести команду:
```bash
$ find ./my-first-blog -name "views.py"
./my-first-blog/blog/views.py
```
Параметр `-name`  вказує на файл з конкретним ім'ям. Якщо замість `-name` вказати
`-iname`, то буде виконано пошук з ігноруванням регістру.

Звісно можна використовувати синтаксис шаблонів:
```bash
$ find ./my-first-blog -name "*init*"
./my-first-blog/mysite/__init__.py
./my-first-blog/blog/migrations/__init__.py
./my-first-blog/blog/migrations/0001_initial.py
./my-first-blog/blog/__init__.py
```

_Пошук за типом_. Припустимо, що нас цікавлять лише директорії, тоді
ми можемо додати параметр `-type`, вказавши тип `d`:
```bash
$ find ./my-first-blog -name "blog" -type d
./my-first-blog/blog
./my-first-blog/blog/templates/blog
```
Типу `f` відповідає звичайний файл, `l` — символічне посилання.

_Пошук за розміром._ Знайти файли та директорії більше 10 МБ:
```bash
$ find ~/Documents -size +10M
```
або менше 1 КБ: `-size -1k`.

Також можна здійснити пошук за датою модифікації (параметр `-mtime`) або
передавати знайдені файли по одному як аргументи іншим командам, використовуючи 
параметр `-exec`.


#### `grep`

`grep` дозволяє шукати текстову інформацію у файлах та потоках виводу Linux. Це надзвичайно зручний інструмент. Наприклад, коли ви відкриваєте незнайомий проект і вам потрібно щось виправити, ви можете швидко знайти потрібний фрагмент у вихідному коді та зрозуміти, де знаходиться потрібна логіка.

Ось класичний спосіб використання `grep`:

```bash
$ grep -rin --include="*.py" "an error occurred" .
```

Тут ми викликаємо команду `grep`, яка шукатиме текст
"an error occurred" у файлах, назви яких закінчуються на `.py`.

Щоб вказати, як і де шукати, ми передаємо параметри:

- `r` — рекурсивний пошук, тобто в директорії та всіх її піддиректоріях.
- `i` — пошук з ігноруванням регістру, тобто будуть знайдені як "Error", так і "error", і "ERROR".
- `n` — ми хочемо виводити не тільки знайдені рядки, але й їх номери, щоб зручно відкрити файл у текстовому редакторі, що підтримує автоматичне відображення номерів рядків.

Додатковий параметр `--include="*.py"` якраз і говорить `grep`, що нас цікавлять лише файли, що закінчуються на `.py`, тобто вихідні коди програм на мові Python.

Точка в кінці команди означає, що ми хочемо шукати в поточній директорії. Якщо б ми хотіли шукати в директорії `/tmp`, то замість крапки вказали б `/tmp`:

```bash
$ grep -rin --include="*.py" "an error occurred" /tmp/
```

Ці параметри є опціональними. Наприклад, ми можемо шукати і так:

```bash
$ grep "an error occurred" /tmp/
```
якщо ми хочемо шукати тільки в директорії `/tmp`, але не в її піддиректоріях, нам не потрібні номери знайдених рядків, регістр тексту саме той, що ми задали, а нас цікавлять файли з будь-яким розширенням, не тільки з Python-кодом.

Може статися так, що результат виконання команди `find` стає досить громіздким. 
В такому разі його можна перенаправити в `grep` за допомогою pipe `|`:
```bash
$ find ./my-first-blog -iname "*.py" | grep "settings"
./my-first-blog/mysite/settings.py
```

Слід пам'ятати про команду `less`. Вонa допомагає в інтерактивному режимі продивлятися вивід інших команд:
```bash
$ find ./my-first-blog -iname "*.py" | less
```
Щоб вийти з режиму перегляду, потрібно натиснути клавішу <kbd>q</kbd>.

### Команда `man`

Під час використання операційної системи Linux вам часто буде потрібно отримати інформацію про те, що робить та чи інша команда або системний виклик, які в них параметри та опції, для чого призначені певні системні файли, який їх формат тощо. Отримати цю інформацію можна за допомогою утиліти `man`:

```bash
man <name>
```

де `name` — це назва команди, утиліти, системного виклику, бібліотечної функції або файлу.

Наприклад:

```bash
man echo
```

Щоб вийти з `man`, натисніть клавішу <kbd>q</kbd>.

Іноді імена команд інтерпретатора та системних викликів або якісь інші імена можуть збігатися. У такому випадку, щоб знайти потрібну інформацію, потрібно вказати утиліті `man` категорію, до якої належить інформація (номер розділу). Поділ інформації за категоріями може трохи відрізнятися для різних версій UNIX. У Linux, наприклад, прийнятий наступний розподіл:

1. Виконувані файли або команди інтерпретатора.
2. Системні виклики.
3. Бібліотечні функції.
4. Спеціальні файли (зазвичай файли пристроїв).
5. Формат системних файлів і прийняті угоди.
6. Ігри (зазвичай відсутні).
7. Макропакети та утиліти, такі як сам `man`.
8. Команди системного адміністратора.
9. Підпрограми ядра (нестандартний розділ).

Якщо ви знаєте розділ, до якого належить інформація, то утиліту `man` можна викликати в Linux з додатковим параметром:

```bash
man <номер_розділу> <name>
```

У інших операційних системах цей виклик може виглядати інакше. Щоб отримати точну інформацію про розбиття на розділи, форму вказівки номера розділу та додаткові можливості утиліти `man`, наберіть команду:

```bash
man man
```

## ✅ TODO

- [ ] Закінчити запланований мінімум
- [ ] Додати посилання до Змісту
