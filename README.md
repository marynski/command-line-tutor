# Робота в командному рядку Linux

## Зміст

- [Введення](#introduction)
  - [Що таке bash](#bash)
- [Команди](#commands)
  - [Команди `cd`, `pwd`, `ls`](#cd-command)
  - [Команди `mkdir`, `touch`, `echo`, `cp`, `mv`, `rm`](#creation)
  - [Жорсткі посилання](#hard-links)
  - [Символічні посилання](#symbolic-links)
  - [Використання wildcards](#wildcards)
  - [Команди find і grep](#find-grep)
  - [Команда man](#man-command)
- [Текстові редактори](#text-editors)
  - [vim](#vim)
  - [nano](#nano)
- [Змінні середовища](#environment-variables)
  - [PATH](#path)
- [Профіль користувача, групи, права доступу](#user-profile-permissions)
  - [chmod](#chmod)
  - [foreground і background процеси](#foreground-background)
  - [Сигнали і команда kill](#signals-kill)
- [Shell скрипти](#shell-scripts)
  - [Запуск Python скриптів](#for-loops)
  - [Конструкція створення циклів "for"](##for-loops)
  - [Арифметика в shell](#arithmetic-shell)
  <!-- - [Команда–переключатель "case"](##case-switch) -->
- [Таблиці команд](#command-tables)
  - [bash](#bash)
  - [Клавіатура vim](#vim-keyboard)
  - [Клавіатура nano](#nano-keyboard)
- [Завдання](#assignments)

## Введення

Інтерфейс командного рядка комп'ютера надає нам тісний
зв'язок з операційною системою (ОС). Командний рядок містить
величезну кількість функцій, відточених і відшліфованих за
десятиліття використання.

### Що таке bash

Bash (акронім від "Bourne-again SHell") — це стандартний інтерпретатор команд на більшості систем Linux. В його обов'язки входить обробка та виконання команд, за допомогою яких користувач керує комп'ютером.

<!-- Після того як ви завершили роботу, можна закінчити процес командного інтерпретатора. Після натискання клавіш `Ctrl–D`, команди `exit` або `logout`, процес командного інтерпретатора буде завершено, і на екрані знову з'явиться запрошення ввести ім'я користувача та пароль. -->

## Команди

Кожна виконувана програма «працює» у строго визначеній
директорії файлової системи. Така директорія називається
поточною директорією; можна уявити, що програма під час
роботи «перебуває» саме в цій директорії — це її «робоче
місце». В залежності від поточної директорії може змінюватися
поведінка програми: часто програма за замовчуванням
працюватиме з файлами, розташованими саме в поточній
директорії — до них вона «дотягнеться» в першу чергу. Поточна
директорія є у будь-якої програми, в тому числі й у командної
оболонки користувача. Оскільки взаємодія користувача з
системою обов'язково опосередкована командною оболонкою,
можна говорити про те, що користувач «перебуває» в тій
директорії, яка в даний момент є поточною директорією його
командної оболонки.

Розглянемо різні команди, які можна виконувати в bash.

### Команди `cd`, `pwd`, `ls`

Почнемо використовувати bash для навігації по файловій
системі. Для початку наберіть наступну команду:

```bash
cd /
```

_change directory_

У наведеному вище прикладі `/` (аргумент команди `cd`)
називається шляхом. Це місце файлової системи, куди ми
хочемо переміститися. Команда `cd` використовується для
зміни поточної робочої директорії.

Усі директорії в системі організовані в деревоподібну
структуру, і `/` — це її початок (або корінь). У цьому
випадку `/` — абсолютний шлях, це означає, що шлях вказаний
відносно кореневої директорії.

<!-- TODO: додати приклад дерева каталогів  -->

Щоб дізнатися, в якому місці файлової системи ви зараз перебуваєте (поточна робоча директорія), наберіть:

```bash
pwd
```

_print working directory_

#### Абсолютні шляхи

Ось кілька прикладів абсолютних шляхів:

```
/dev
/usr
/usr/bin
/usr/local/bin
```

Усі ці шляхи об'єднує те, що вони починаються з `/`.
Вказуючи шлях `/usr/local/bin` в якості аргументу команді
`cd`, ми говоримо їй перейти до кореневої директорії `/`,
потім до директорії `usr`, далі до `local` і `bin`.
Абсолютні шляхи завжди починаються з `/`.

#### Відносні шляхи

Другий вид шляхів називається відносними. Bash, команда `cd` та інші команди
відраховують ці шляхи відносно поточної директорії. Відносні
шляхи ніколи не починаються з `/`. Наприклад, якщо ми
знаходимося в `/usr` (`cd /usr`), ми можемо перейти в `/usr/
local/bin`, використовуючи відносний шлях:

```bash
cd local/bin
pwd
# /usr/local/bin
```

#### Використання "\.\."

Директорія `..` вказує на батьківську директорію відносно нашої робочої директорії. Приклад:

```bash
pwd
# /usr/local/bin
cd ..
pwd
# /usr/local
```

Команда `cd ..` «піднімає на рівень вище». Можна додати `..`
до відносного шляху. Це дозволить переміститися в
директорію, яка знаходиться на одному рівні з тією, яка є
робочою. Приклад:

```bash
pwd
# /usr/local
cd ../share
pwd
# /usr/share
```

#### Приклади з використанням відносних шляхів

Відносні шляхи можуть бути досить складними. Ось кілька
прикладів. Результат виконання команд не показаний,
спробуйте визначити, в якій директорії ви опинитеся,
використовуючи bash.

```bash
cd /bin
cd ../usr/share/zoneinfo

cd /usr/lib/debug/lib
cd ../usr/lib

cd /usr/bin
cd ../bin/../bin
```

#### Робоча директорія "\."

Перед тим як завершити розгляд команди `cd`, слід згадати,
що існує ще одна спеціальна директорія `.` (точка), яка
вказує на поточну директорію. Ця директорія використовується
для запуску виконуваних файлів, що знаходяться в поточній
директорії.

```bash
./myprog
```

У останньому прикладі `myprog` — це виконуваний файл, що
знаходиться в поточній директорії, який буде запущено на
виконання.

#### <span style="font-size: 24px;">cd</span> і домашня директорія користувача

Щоб перейти до домашньої директорії, потрібно ввести:

```bash
cd
```

або

```bash
cd ~
```

Без аргументів команда `cd` зробить домашню директорію
поточною. Тильда `~` — спеціальне ім'я, яке в bash вказує на
домашню директорію користувача. Для суперкористувача
домашньою зазвичай є директорія `/root` (або `/var/root/` на
macOS), а для звичайних користувачів — `/home/<username>/`
(або `/Users/<username>/` на macOS).

Якщо потрібно вказати конкретний файл, що знаходиться в
домашній директорії, то можна написати:

```bash
./myprog /home/user/myfile.txt
```

Використовувати абсолютні шляхи до файлів не завжди зручно.
Цю ж операцію можна виконати за допомогою тильди `~`:

```bash
./myprog ~/myfile.txt
```

### <span style="font-size: 24px;">ls</span>

Команда `ls`, викликана без аргументів, виводить на екран список файлів, що зберігаються в робочій директорії:

```bash
$ cd /usr
$ ls
X11R6      doc         i686-pc-linux-gnu  lib      man          sbin   ssl
bin        gentoo-x86  include            libexec  portage      share  tmp
distfiles  i686-linux  info               local    portage.old  src
```

Якщо вказати опцію `-a`, можна буде побачити всі файли, включаючи приховані (імена яких починаються з точки).

```bash
$ ls -a
.      bin        gentoo-x86         include  libexec  portage      share  tmp
..     distfiles  i686-linux         info     local    portage.old  src
X11R6  doc        i686-pc-linux-gnu  lib      man      sbin         ssl
```

Після команди `ls` в якості її аргументу можна вказати один або більше файлів або директорій. Якщо вказати ім'я файлу, команда `ls` виведе інформацію лише про цей файл. Якщо вказати назву директорії, `ls` покаже все її вміст.

Опція `-l` команди `ls` дуже корисна, якщо потрібно, окрім імен файлів, дізнатися більш детальну інформацію про них (права на файл, ім'я власника, час останньої зміни файлу і його розмір). Додавання опції `-t` сортує файли за датою останньої зміни, а `-r` — сортує результати у зворотному порядку. У наступному прикладі показано застосування опції `-l` для виводу інформації про файли, що зберігаються в директорії `/usr`:

```bash
$ ls -l /usr
drwxr-xr-x    7 root     root          168 Nov 24 14:02 X11R6
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 bin
drwxr-xr-x    2 root     root         8856 Dec 26 12:47 distfiles
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 doc -> share/doc
drwxr-xr-x   62 root     root         1856 Dec 27 15:54 gentoo-x86
drwxr-xr-x    4 root     root          152 Dec 12 23:10 i686-linux
drwxr-xr-x    4 root     root           96 Nov 24 13:17 i686-pc-linux-gnu
drwxr-xr-x   54 root     root         5992 Dec 24 22:30 include
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 info -> share/info
drwxr-xr-x   28 root     root        13552 Dec 26 00:31 lib
drwxr-xr-x    3 root     root           72 Nov 25 00:34 libexec
drwxr-xr-x    8 root     root          240 Dec 22 20:57 local
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 man -> share/man
lrwxrwxrwx    1 root     root           11 Dec  8 07:59 portage -> gentoo-x86/
drwxr-xr-x   60 root     root         1864 Dec  8 07:55 portage.old
drwxr-xr-x    3 root     root         3096 Dec 22 20:57 sbin
drwxr-xr-x   46 root     root         1144 Dec 24 15:32 share
drwxr-xr-x    8 root     root          328 Dec 26 00:07 src
drwxr-xr-x    6 root     root          176 Nov 24 14:25 ssl
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 tmp -> ../var/tmp
```

У першій колонці показана інформація про права доступу до кожного файлу в списку. Наступна колонка показує кількість посилань на кожен елемент списку. Третя та четверта колонки — власник і група файлу відповідно. П’ята колонка — розмір. Шоста — час останньої зміни файлу (модифікації). Остання колонка — ім'я файлу або директорії (якщо це посилання, то після знака `->` стоїть ім'я об'єкта, на який воно посилається).

Іноді виникає потреба подивитися інформацію лише про директорії, а не про все їх вміст. Для цього потрібно скористатися опцією `-d`, яка вказує команді виводити інформацію лише про директорії. Приклад:

```bash
$ ls -dl /usr /usr/bin /usr/X11R6/bin ../share
drwxr-xr-x    4 root     root           96 Dec 18 18:17 ../share
drwxr-xr-x   17 root     root          576 Dec 24 09:03 /usr
drwxr-xr-x    2 root     root         3192 Dec 26 12:52 /usr/X11R6/bin
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 /usr/bin
```

Дія опції `-R` є протилежною дії `-d`. Вона дозволяє виводити інформацію про файли, що знаходяться в директорії рекурсивно. Спочатку показується вміст директорії верхнього рівня, потім по черзі вміст усіх піддиректорій і так далі. Вивід цієї команди може бути досить об'ємним, тому приклад не наводиться, але можна спробувати зробити це самостійно, набравши в командному рядку `ls -R` або `ls -Rl`.

І, нарешті, опція `-i` використовується для виводу inode кожного об'єкта файлової системи.

```bash
$ ls -i /usr
1409 X11R6        314258 i686-linux           43090 libexec        13394 sbin
1417 bin            1513 i686-pc-linux-gnu     5120 local          13408 share
8316 distfiles      1517 include                776 man            23779 src
43 doc            1386 info                 93892 portage        36737 ssl
70744 gentoo-x86     1585 lib                   5132 portage.old      784 tmp
```

Кожен об'єкт файлової системи (файл, директорія тощо) має свій унікальний номер, званий інодом (inode number). Ця інформація може здаватися незначною, але розуміння функції inode дозволяє розібратися у багатьох операціях над файловою системою. Наприклад, розглянемо `.` і `..` як посилання, присутні в кожній директорії. Щоб зрозуміти, що з себе представляє директорія `..`, дізнаємося inode директорії `/usr/local`:

```bash
$ ls -id /usr/local
5120 /usr/local
```

У цьому прикладі inode директорії `/usr/local` — `5120`. Тепер подивимося, який inode у директорії `/usr/local/bin/..`:

```bash
$ ls -id /usr/local/bin/..
5120 /usr/local/bin/..
```

Виходить, що inode директорій `/usr/local` і `/usr/local/bin/..` збігаються. Це означає, що на inode `5120` посилаються два імені: `/usr/local` і `/usr/local/bin/..`. Тобто це два різних імені однієї директорії. Кожен inode вказує на певне місце на диску. З кожним inode може бути пов'язано кілька імен об'єктів файлової системи. Кількість «синонімів» файлу (об'єктів файлової системи, що посилаються на один inode) показує число у другому стовпці виводу команди `ls -l`:

```bash
$ ls -dl /usr/local
drwxr-xr-x    8 root     root          240 Dec 22 20:57 /usr/local
```

У цьому прикладі видно (другий стовпець), що на директорію `/usr/local` посилаються 8 різних об'єктів. Ось
їх імена:

```
/usr/local
/usr/local/.
/usr/local/bin/..
/usr/local/games/..
/usr/local/lib/..
/usr/local/sbin/..
/usr/local/share/..
/usr/local/src/..
```

### Команди `mkdir`, `touch`, `echo`, `cp`, `mv`, `rm`

#### mkdir

Розглянемо команду `mkdir`. Вона слугує для створення нових директорій. У наступному прикладі демонструється створення трьох нових директорій (tic, tac, toe) у директорії `/tmp`:

```bash
$ cd /tmp
$ mkdir tic tac toe
```

За замовчуванням команда `mkdir` не може створити вкладену структуру директорій. Тому, якщо вам потрібно створити кілька вкладених директорій (наприклад, `won/der/ful`), доведеться тричі по черзі викликати цю команду:

```bash
$ mkdir won/der/ful
mkdir: cannot create directory 'won/der/ful': No such file or directory
$ mkdir won
$ mkdir won/der
$ mkdir won/der/ful
```

Упростити цю операцію можна, додавши опцію `-p` до команди `mkdir`. Ця опція дозволяє створювати вкладену структуру директорій:

```bash
$ mkdir -p easy/as/pie
```

Щоб дізнатися про можливості цієї утиліти детальніше, прочитайте довідку, яка викликається командою `man mkdir`. Довідки є практично до всіх команд, розглянутих у цій посібнику (наприклад, `man ls`), крім `cd`, оскільки вона вбудована в bash (для таких команд довідка викликається так: `help cd`).

#### touch, echo, cp, mv

Перейдемo до вивчення команд `cp` та `mv`, які слугують для копіювання, перейменування та переміщення файлів і директорій. Але спочатку створимо пустий файл у директорії `/tmp` за допомогою команди `touch`:

```bash
$ cd /tmp
$ touch copyme
```

Команда `touch` оновлює час останнього доступу до файлу (шоста колонка виводу команди `ls -l`), якщо файл вже існує, або створює новий пустий файл, якщо його ще немає. Після цієї операції повинен з'явитися пустий файл `/tmp/copyme`.

#### Перенаправлення вводу-виводу

Тепер, коли у нас є пустий файл, запишемо в нього текстову строку за допомогою команди `echo`, яка виводить переданий їй аргумент на стандартне пристрій виводу (текстовий термінал у нашому випадку):

```bash
$ echo "firstfile"
firstfile
```

Щоб записати строку в наш файл, потрібно перенаправити в нього вивід команди `echo`:

```bash
$ echo "firstfile" > copyme
```

Знак `>` (більше) вказує командній оболонці, що потрібно перенаправити вивід команди зліва в файл, ім'я якого знаходиться справа. Якщо файлу з таким ім'ям не існує, він буде створений автоматично. А якщо такий файл вже є, то він буде перезаписаний (усе його вміст буде стерто перед записом нашої строки). Команда `ls -l` покаже, що розмір створеного файлу тепер становить 10 байт — дев'ять байт займає слово 'firstfile' і один байт символ зміни рядка (`\n` line feed).

```bash
$ ls -l copyme
-rw-r--r--    1 root     root           10 Dec 28 14:13 copyme
```

Для виводу вмісту файлу в термінал використовується команда `cat`:

```bash
$ cat copyme
firstfile
```

Вивід команди `cat` також можна перенаправити з екрану термінала в якийсь файл.
Команда:

 <!-- скориставшись символом перенаправлення вихідного потоку даних — знаком "більше" — `>` -->

```bash
$ cat copyme1 copyme2 ... copymeN > copyme
```

запише вміст усіх файлів, імена яких стоять перед знаком `>`, воєдино в «copyme» — конкатенує їх. Перенаправлення вихідних даних зі стандартного потоку виводу (екрана) у файл є стандартним для всіх команд, що виконуються командним інтерпретатором. Ви можете отримати файл, що містить список усіх файлів поточної директорії, якщо виконаєте команду:

```bash
$ ls -a > list.txt
```

Якщо імена вхідних файлів для команди `cat` не задані, то вона використовуватиме як вхідні дані інформацію, що вводиться з клавіатури, до тих пір, поки ви не наберете ознаку закінчення вводу — комбінацію клавіш `<CTRL>` і `d`.

Отже, команда:

```bash
$ cat > copyme
```

дозволяє створити новий текстовий файл з ім'ям «copyme» і вмістом, яке користувач введе з клавіатури. У команди `cat` існує безліч різних опцій. Подивитися її повний опис можна за допомогою `man cat`.

Зверніть увагу, що поряд з перенаправленням вихідних даних існує спосіб перенаправити вхідні дані. Якщо під час виконання якоїсь команди потрібно ввести дані з клавіатури, можна покласти їх заздалегідь у файл, а потім перенаправити стандартний ввід цієї команди за допомогою знака "менше" — `<` і наступного за ним імені файлу з вхідними даними.

Перенаправлення за допомогою `>` перезаписує вміст файлу заново. Якщо потрібно дописати в кінець, слід скористатися `>>`.

Наприклад:

```bash
[user@comp ~]$ ls -a > list.txt
[user@comp ~]$ ls -a >> list.txt
```

Файл `list.txt` буде містити результат роботи обох запусків команди `ls`.

Для поетапного перегляду вмісту файлу можна використовувати команди `less` або `more`. Якщо потрібно вивести перші або останні рядки файлу, скористайтеся командами `head`/`tail`. Команда `head` виводить перші десять рядків файлу, а `tail` — останні десять. Кількість рядків задається за допомогою параметра `-n`.

Тепер розглянемо базову функціональність команди `cp`. Ця команда приймає два аргументи. Перший — ім'я вже існуючого файлу (`copyme`), другий — назва нової копії, яку потрібно створити (`copiedme`).

```bash
$ cp copyme copiedme
```

Нова копія файлу має інший номер inode (це означає, що був створений дійсно новий окремий файл, а не просто посилання на старий).

```bash
$ ls -i copyme copiedme
648284 copiedme   650704 copyme
```

Тепер застосуємо команду `mv`, щоб перейменувати файл ("copiedme" → "movedme"). Номер inode після цієї операції не змінюється, а змінюється лише назва файлу.

```bash
$ mv copiedme movedme
$ ls -i movedme
648284 movedme
```

Номер inode не змінюється лише за умови, що перейменований файл залишається в межах тієї файлової системи, де знаходився вихідний файл. Команда `mv` дозволяє не лише перейменовувати файли, але й переміщати їх. Наприклад, щоб перемістити файл `/var/tmp/myfile.txt` у директорію `/home/user`, потрібно дати команду:

```bash
$ mv /var/tmp/myfile.txt /home/user
```

Файл буде переміщений у домашню директорію користувача `user`, навіть якщо вона знаходиться в іншій файловій системі (в цьому випадку файл буде скопійований у нове місце, після чого оригінал буде видалений). Переміщення файлу в іншу файлову систему призводить до зміни його inode. Це відбувається, оскільки кожна файлова система має свій окремий набір inode. Варто зазначити, що існує ймовірність, що новий присвоєний номер inode може збігтися зі старим, але вона надзвичайно мала.

Щоб перемістити одночасно кілька файлів в одну директорію, потрібно написати:

```bash
$ mv /var/tmp/myfile1.txt /var/tmp/myfile2.txt /home/user
```

або

```bash
$ mv -t /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
```

Якщо додати опцію `-v`, на екран буде виведено звіт про виконану операцію:

```bash
$ mv -vt /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
'/var/tmp/myfile1.txt' -> '/home/user/myfile1.txt'
'/var/tmp/myfile2.txt' -> '/home/user/myfile2.txt'
```

## ✅ TODO
- [ ] Закінчити запланований мінімум
- [ ] Додати посилання до Змісту



