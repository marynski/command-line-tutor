# Робота в командному рядку Linux

## Зміст

- [Введення](#Введення)
  - [Що таке bash](#що-таке-bash)
- [Команди](#команди)
  - [Команди `cd`, `pwd`, `ls`](#команди-cd-pwd-ls)
  - [Перенаправлення вводу-виводу](#перенаправлення-вводу-виводу)
  - [Команди `mkdir`, `cp`, `mv`, `rm`](#команди-mkdir-cp-mv-rm)
  - [Жорсткі посилання](#жорсткі-посилання)
  - [Символічні посилання](#символічні-посилання)
  - [Використання wildcards](#використання-шаблонів-wildcards)
  - [Команди find і grep](#команди-find-і-grep)
  - [Команда man](#команда-man)
- [Текстові редактори](#текстові-редактори)
  - [vim](#vim)
  - [nano](#nano)
- [Змінні середовища](#змінні-середовища)
  - [Маніпуляції зі змінними](#маніпуляції-зі-змінними)
  - [PATH](#path)
- [Профіль користувача, групи, права доступу](#профіль-користувача-групи-права-доступу)
  - [chmod](#chmod)
  - [Foreground і Background процеси](#foreground-і-background-процеси)
  - [Сигнали і команда kill](#сигнали-і-команда-kill)
- [Скрипти](#скрипти)
  - [Shell скрипти](#shell-скрипти)
  - [Конструкція створення циклів "for"](#конструкція-створення-циклів-for)
  - [Арифметика в shell](#арифметика-в-shell)
  - [Запуск Python скриптів](#запуск-python-скриптів)
- [Таблиці команд](#таблиці-команд)
  - [bash](#bash)
  - [Клавіатура vim](#клавіатура-vim)
  - [Клавіатура nano](#клавіатура-nano)

## Введення

Інтерфейс командного рядка комп'ютера надає нам тісний
зв'язок з операційною системою (ОС). Командний рядок містить
величезну кількість функцій, відточених і відшліфованих за
десятиліття використання.

### Що таке bash

Bash (акронім від "Bourne-again SHell") — це стандартний інтерпретатор команд на більшості систем Linux. В його обов'язки входить обробка та виконання команд, за допомогою яких користувач керує комп'ютером.

<!-- Після того як ви завершили роботу, можна закінчити процес командного інтерпретатора. Після натискання клавіш `Ctrl–D`, команди `exit` або `logout`, процес командного інтерпретатора буде завершено, і на екрані знову з'явиться запрошення ввести ім'я користувача та пароль. -->

## Команди

Кожна виконувана програма «працює» у строго визначеній
директорії файлової системи. Така директорія називається
поточною директорією; можна уявити, що програма під час
роботи «перебуває» саме в цій директорії — це її «робоче
місце». В залежності від поточної директорії може змінюватися
поведінка програми: часто програма за замовчуванням
працюватиме з файлами, розташованими саме в поточній
директорії — до них вона «дотягнеться» в першу чергу. Поточна
директорія є у будь-якої програми, в тому числі й у командної
оболонки користувача. Оскільки взаємодія користувача з
системою обов'язково опосередкована командною оболонкою,
можна говорити про те, що користувач «перебуває» в тій
директорії, яка в даний момент є поточною директорією його
командної оболонки.

Розглянемо різні команди, які можна виконувати в bash.

## Команди `cd`, `pwd`, `ls`

#### Знайомство з `cd`

Почнемо використовувати bash для навігації по файловій
системі. Для початку наберіть наступну команду:

```bash
cd /
```

_change directory_

Команда `cd` використовується для зміни поточної робочої директорії.
У наведеному вище прикладі `/` (аргумент команди `cd`)
називається шляхом. Це місце файлової системи, куди ми
хочемо переміститися.

Усі директорії в системі організовані в деревоподібну
структуру, і `/` — це її початок (або корінь).

<!-- TODO: додати приклад дерева каталогів  -->

Щоб дізнатися, в якому місці файлової системи ви зараз перебуваєте (поточна робоча директорія), наберіть:

```bash
pwd
```

_print working directory_

#### Абсолютні шляхи

Шлях, вказаний відносно кореневої директорії `/`, називається абсолютним.

Ось кілька прикладів абсолютних шляхів:

```
/dev
/usr
/usr/bin
/usr/local/bin
```

Усі ці шляхи об'єднує те, що вони починаються з `/`.
Вказуючи шлях `/usr/local/bin` в якості аргументу команді
`cd`, ми говоримо їй перейти до кореневої директорії `/`,
потім до директорії `usr`, далі до `local` і `bin`.
Абсолютні шляхи завжди починаються з `/`.

#### Відносні шляхи

Другий вид шляхів називається відносними. Bash, команда `cd` та інші команди
відраховують ці шляхи відносно поточної директорії. Відносні
шляхи ніколи не починаються з `/`. Наприклад, якщо ми
знаходимося в `/usr` (`cd /usr`), ми можемо перейти в
`/usr/local/bin`, використовуючи відносний шлях:

```bash
cd local/bin
pwd
# /usr/local/bin
```

#### Використання "\.\."

Директорія `..` вказує на батьківську директорію відносно нашої робочої директорії. Приклад:

```bash
pwd
# /usr/local/bin
cd ..
pwd
# /usr/local
```

Команда `cd ..` «піднімає на рівень вище». Можна додати `..`
до відносного шляху. Це дозволить переміститися в
директорію, яка знаходиться на одному рівні з тією, яка є
робочою. Приклад:

```bash
pwd
# /usr/local
cd ../share
pwd
# /usr/share
```

#### Приклади з використанням відносних шляхів

Відносні шляхи можуть бути досить складними. Ось кілька
прикладів. Результат виконання команд не показаний,
спробуйте визначити, в якій директорії ви опинитеся,
використовуючи bash.

```bash
cd /bin
cd ../usr/share/zoneinfo

cd /usr/lib/debug/lib
cd ../usr/lib

cd /usr/bin
cd ../bin/../bin
```

#### Робоча директорія "\."

Перед тим як завершити розгляд команди `cd`, слід згадати,
що існує ще одна спеціальна директорія `.` (точка), яка
вказує на поточну директорію. Ця директорія використовується
для запуску виконуваних файлів, що знаходяться в поточній
директорії.

```bash
./myprog
```

У останньому прикладі `myprog` — це виконуваний файл, що
знаходиться в поточній директорії, який буде запущено на
виконання.

#### `cd` і домашня директорія користувача

Щоб перейти до домашньої директорії, потрібно ввести:

```bash
cd
```

або

```bash
cd ~
```

Без аргументів команда `cd` зробить домашню директорію
поточною. Тильда `~` — спеціальне ім'я, яке в bash вказує на
домашню директорію користувача. Для суперкористувача
домашньою зазвичай є директорія `/root` (або `/var/root/` на
macOS), а для звичайних користувачів — `/home/<username>/`
(або `/Users/<username>/` на macOS).

Якщо потрібно вказати конкретний файл, що знаходиться в
домашній директорії, то можна написати:

```bash
./myprog /home/user/myfile.txt
```

Використовувати абсолютні шляхи до файлів не завжди зручно.
Цю ж операцію можна виконати за допомогою тильди `~`:

```bash
./myprog ~/myfile.txt
```

#### `ls`

Команда `ls`, викликана без аргументів, виводить на екран список файлів, що зберігаються в робочій директорії:

```bash
$ cd /usr
$ ls
X11R6      doc         i686-pc-linux-gnu  lib      man          sbin   ssl
bin        gentoo-x86  include            libexec  portage      share  tmp
distfiles  i686-linux  info               local    portage.old  src
```

Якщо вказати опцію `-a`, можна буде побачити всі файли, включаючи приховані (імена яких починаються з точки).

```bash
$ ls -a
.      bin        gentoo-x86         include  libexec  portage      share  tmp
..     distfiles  i686-linux         info     local    portage.old  src
X11R6  doc        i686-pc-linux-gnu  lib      man      sbin         ssl
```

Після команди `ls` в якості її аргументу можна вказати один або більше файлів або директорій. Якщо вказати ім'я файлу, команда `ls` виведе інформацію лише про цей файл. Якщо вказати назву директорії, `ls` покаже все її вміст.

Опція `-l` команди `ls` дуже корисна, якщо потрібно, окрім імен файлів, дізнатися більш
детальну інформацію про них (права на файл, ім'я власника, час останньої зміни файлу і
його розмір). Додавання опції `-t` сортує файли за датою останньої зміни, а `-r` — сортує
результати у зворотному порядку. У наступному прикладі показано застосування опції `-l`
для виводу інформації про файли, що зберігаються в директорії `/usr`:

```bash
$ ls -l /usr
drwxr-xr-x    7 root     root          168 Nov 24 14:02 X11R6
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 bin
drwxr-xr-x    2 root     root         8856 Dec 26 12:47 distfiles
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 doc -> share/doc
drwxr-xr-x   62 root     root         1856 Dec 27 15:54 gentoo-x86
drwxr-xr-x    4 root     root          152 Dec 12 23:10 i686-linux
drwxr-xr-x    4 root     root           96 Nov 24 13:17 i686-pc-linux-gnu
drwxr-xr-x   54 root     root         5992 Dec 24 22:30 include
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 info -> share/info
drwxr-xr-x   28 root     root        13552 Dec 26 00:31 lib
drwxr-xr-x    3 root     root           72 Nov 25 00:34 libexec
drwxr-xr-x    8 root     root          240 Dec 22 20:57 local
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 man -> share/man
lrwxrwxrwx    1 root     root           11 Dec  8 07:59 portage -> gentoo-x86/
drwxr-xr-x   60 root     root         1864 Dec  8 07:55 portage.old
drwxr-xr-x    3 root     root         3096 Dec 22 20:57 sbin
drwxr-xr-x   46 root     root         1144 Dec 24 15:32 share
drwxr-xr-x    8 root     root          328 Dec 26 00:07 src
drwxr-xr-x    6 root     root          176 Nov 24 14:25 ssl
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 tmp -> ../var/tmp
```

У першій колонці показана інформація про права доступу до кожного файлу в списку.
Наступна колонка показує кількість посилань на кожен елемент списку. Третя та четверта
колонки — власник і група файлу відповідно. П’ята колонка — розмір. Шоста — час останньої
зміни файлу (модифікації). Остання колонка — ім'я файлу або директорії (якщо це
посилання, то після знака `->` стоїть ім'я об'єкта, на який воно посилається).

Іноді виникає потреба подивитися інформацію лише про директорії, а не про все їх вміст.
Для цього потрібно скористатися опцією `-d`, яка вказує команді виводити інформацію лише
про директорії. Приклад:

```bash
$ ls -dl /usr /usr/bin /usr/X11R6/bin ../share
drwxr-xr-x    4 root     root           96 Dec 18 18:17 ../share
drwxr-xr-x   17 root     root          576 Dec 24 09:03 /usr
drwxr-xr-x    2 root     root         3192 Dec 26 12:52 /usr/X11R6/bin
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 /usr/bin
```

Дія опції `-R` є протилежною дії `-d`. Вона дозволяє виводити інформацію про файли, що
знаходяться в директорії рекурсивно. Спочатку показується вміст директорії верхнього
рівня, потім по черзі вміст усіх піддиректорій і так далі. Вивід цієї команди може бути
досить об'ємним, тому приклад не наводиться, але можна спробувати зробити це самостійно,
набравши в командному рядку `ls -R` або `ls -Rl`.

І, нарешті, опція `-i` використовується для виводу inode кожного об'єкта файлової системи.

```bash
$ ls -i /usr
1409 X11R6        314258 i686-linux           43090 libexec        13394 sbin
1417 bin            1513 i686-pc-linux-gnu     5120 local          13408 share
8316 distfiles      1517 include                776 man            23779 src
43 doc            1386 info                 93892 portage        36737 ssl
70744 gentoo-x86     1585 lib                   5132 portage.old      784 tmp
```

Кожен об'єкт файлової системи (файл, директорія тощо) має свій унікальний номер, званий
інодом (inode number). Ця інформація може здаватися незначною, але розуміння функції
inode дозволяє розібратися у багатьох операціях над файловою системою. Наприклад,
розглянемо `.` і `..` як посилання, присутні в кожній директорії. Щоб зрозуміти, що з
себе представляє директорія `..`, дізнаємося inode директорії `/usr/local`:

```bash
$ ls -id /usr/local
5120 /usr/local
```

У цьому прикладі inode директорії `/usr/local` — `5120`. Тепер подивимося, який inode у
директорії `/usr/local/bin/..`:

```bash
$ ls -id /usr/local/bin/..
5120 /usr/local/bin/..
```

Виходить, що inode директорій `/usr/local` і `/usr/local/bin/..` збігаються. Це означає,
що на inode `5120` посилаються два імені: `/usr/local` і `/usr/local/bin/..`. Тобто це
два різних імені однієї директорії. Кожен inode вказує на певне місце на диску. З кожним
inode може бути пов'язано кілька імен об'єктів файлової системи. Кількість «синонімів»
файлу (об'єктів файлової системи, що посилаються на один inode) показує число у другому
стовпці виводу команди `ls -l`:

```bash
$ ls -dl /usr/local
drwxr-xr-x    8 root     root          240 Dec 22 20:57 /usr/local
```

У цьому прикладі видно (другий стовпець), що на директорію `/usr/local` посилаються 8
різних об'єктів. Ось
їх імена:

```
/usr/local
/usr/local/.
/usr/local/bin/..
/usr/local/games/..
/usr/local/lib/..
/usr/local/sbin/..
/usr/local/share/..
/usr/local/src/..
```

## Перенаправлення вводу-виводу

<!-- Перед тим як перейти -->
<!-- до вивчення команд, які слугують для створення, видалення, -->
<!-- копіювання, перейменування та переміщення файлів і директорій -->

Спочатку створимо пустий файл у директорії `/tmp` за
допомогою команди `touch`:

```bash
$ cd /tmp
$ touch copyme
```

Команда `touch` оновлює час останнього доступу до файлу (шоста колонка виводу команди
`ls -l`), якщо файл вже існує, або створює новий пустий файл, якщо його ще немає. Після
цієї операції повинен з'явитися пустий файл `/tmp/copyme`.

Тепер, коли у нас є пустий файл, запишемо в нього текстову строку за допомогою команди
`echo`, яка виводить переданий їй аргумент в стандартний пристрій виводу
(текстовий термінал у нашому випадку):

```bash
$ echo "firstfile"
firstfile
```

Щоб записати строку в наш файл, потрібно перенаправити в нього вивід команди `echo`:

```bash
$ echo "firstfile" > copyme
```

Знак `>` (більше) вказує командній оболонці, що потрібно перенаправити вивід команди
зліва в файл, ім'я якого знаходиться справа. Якщо файлу з таким ім'ям не існує,
він буде створений автоматично. А якщо такий файл вже є, то він буде перезаписаний
(усе його вміст буде стерто перед записом нашої строки). Команда `ls -l` покаже,
що розмір створеного файлу тепер становить 10 байт — дев'ять байт займає слово
'firstfile' і один байт символ зміни рядка (`\n` line feed).

```bash
$ ls -l copyme
-rw-r--r--    1 root     root           10 Dec 28 14:13 copyme
```

Для виводу вмісту файлу в термінал використовується команда `cat`:

```bash
$ cat copyme
firstfile
```

Вивід команди `cat` також можна перенаправити з екрану термінала в якийсь файл.
Команда:

```bash
$ cat copyme1 copyme2 ... copymeN > copyme
```

запише вміст усіх файлів, імена яких стоять перед знаком `>`, воєдино в «copyme» —
конкатенує їх. Перенаправлення вихідних даних зі стандартного потоку виводу (екрана) у
файл є стандартним для всіх команд, що виконуються командним інтерпретатором.

Ви можете
отримати файл, що містить список усіх файлів поточної директорії, якщо виконаєте команду:

```bash
$ ls -a > list.txt
```

Якщо імена вхідних файлів для команди `cat` не задані, то вона використовуватиме як
вхідні дані інформацію, що вводиться з клавіатури, до тих пір, поки ви не натиснете
закінчення вводу — комбінацію клавіш <kbd>Ctrl+D</kbd> або <kbd>Ctrl+C</kbd>.

Отже, команда:

```bash
$ cat > copyme
```

дозволяє створити новий текстовий файл з ім'ям «copyme» і вмістом,
який користувач введе з
клавіатури. У команди `cat` існує безліч різних опцій. Подивитися її повний опис можна за
допомогою `man cat`.

Зверніть увагу, що поряд з перенаправленням вихідних даних існує спосіб перенаправити
вхідні дані. Якщо під час виконання якоїсь команди потрібно ввести дані з клавіатури,
можна покласти їх заздалегідь у файл, а потім перенаправити стандартний ввід цієї команди
за допомогою знака "менше" — `<` і наступного за ним імені файлу з вхідними даними.

Перенаправлення за допомогою `>` перезаписує вміст файлу заново. Якщо потрібно дописати в
кінець, слід скористатися `>>`.

Наприклад:

```bash
$ ls -a > list.txt
$ ls -a >> list.txt
```

Файл `list.txt` буде містити результат роботи обох запусків команди `ls`.

Для поетапного перегляду вмісту файлу можна використовувати команди `less` або `more`.
Якщо потрібно вивести перші або останні рядки файлу, скористайтеся командами `head`/
`tail`. Команда `head` виводить перші десять рядків файлу, а `tail` — останні десять.
Кількість рядків задається за допомогою параметра `-n`.

### Команди `mkdir`, `cp`, `mv`, `rm`

#### `mkdir`

Розглянемо команду `mkdir`. Вона слугує для створення нових директорій. У наступному прикладі демонструється створення трьох нових директорій (tic, tac, toe) у директорії `/tmp`:

```bash
$ cd /tmp
$ mkdir tic tac toe
```

За замовчуванням команда `mkdir` не може створити вкладену структуру директорій. Тому, якщо вам потрібно створити кілька вкладених директорій (наприклад, `won/der/ful`), доведеться тричі по черзі викликати цю команду:

```bash
$ mkdir won/der/ful
mkdir: cannot create directory 'won/der/ful': No such file or directory
$ mkdir won
$ mkdir won/der
$ mkdir won/der/ful
```

Упростити цю операцію можна, додавши опцію `-p` до команди `mkdir`. Ця опція дозволяє
створювати вкладену структуру директорій:

```bash
$ mkdir -p easy/as/pie
```

Щоб дізнатися про можливості цієї утиліти детальніше, прочитайте довідку, яка
викликається командою `man mkdir`. Довідки є практично до всіх команд, розглянутих у цій
посібнику (наприклад, `man ls`), крім `cd`, оскільки вона вбудована в bash (для таких
команд довідка викликається так: `help cd`).

#### `cp`

Тепер розглянемо базову функціональність команди `cp`. Ця команда приймає два аргументи.
Перший — ім'я вже існуючого файлу (`copyme`), другий — назва нової копії, яку потрібно
створити (`copiedme`).

```bash
$ cp copyme copiedme
```

Нова копія файлу має інший номер inode (це означає, що був створений дійсно новий окремий
файл, а не просто посилання на старий).

```bash
$ ls -i copyme copiedme
648284 copiedme   650704 copyme
```

#### `mv`

Тепер застосуємо команду `mv`, щоб перейменувати файл ("copiedme" → "movedme"). Номер
inode після цієї операції не змінюється, а змінюється лише назва файлу.

```bash
$ mv copiedme movedme
$ ls -i movedme
648284 movedme
```

Номер inode не змінюється лише за умови, що перейменований файл залишається в межах тієї
файлової системи, де знаходився вихідний файл. Команда `mv` дозволяє не лише
перейменовувати файли, але й переміщати їх. Наприклад, щоб перемістити файл
`/var/tmp/myfile.txt` у директорію `/home/user`, потрібно дати команду:

```bash
$ mv /var/tmp/myfile.txt /home/user
```

Файл буде переміщений у домашню директорію користувача `user`, навіть якщо вона
знаходиться в іншій файловій системі (в цьому випадку файл буде скопійований у нове
місце, після чого оригінал буде видалений). Переміщення файлу в іншу файлову систему
призводить до зміни його inode. Це відбувається, оскільки кожна файлова система має свій
окремий набір inode. Варто зазначити, що існує ймовірність, що новий присвоєний номер
inode може збігтися зі старим, але вона надзвичайно мала.

Щоб перемістити одночасно кілька файлів в одну директорію, потрібно написати:

```bash
$ mv /var/tmp/myfile1.txt /var/tmp/myfile2.txt /home/user
```

або

```bash
$ mv -t /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
```

Якщо додати опцію `-v`, на екран буде виведено звіт про виконану операцію:

```bash
$ mv -vt /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
'/var/tmp/myfile1.txt' -> '/home/user/myfile1.txt'
'/var/tmp/myfile2.txt' -> '/home/user/myfile2.txt'
```

#### `rm`

Тепер, після ознайомлення з командами `mkdir`, `cp` і `mv`, розглянемо, як видаляти файли.
Зазвичай видалення виконується за допомогою команди `rm`.
Щоб видалити кілька файлів, потрібно вказати їхні імена через пробіл у командному
рядку як аргументи до `rm`:

```bash
$ cd /tmp
$ touch file1 file2
$ ls -l file1 file2
-rw-r--r--    1 root     root            0 Jan  1 16:41 file1
-rw-r--r--    1 root     root            0 Jan  1 16:41 file2
$ rm file1 file2
$ ls -l file1 file2
ls: file1: No such file or directory
ls: file2: No such file or directory
```

Видалені файли неможливо відновити (хоча можна спробувати). Тому багато початківців у
Linux використовують опцію `-i` команди `rm`, яка запитує у користувача підтвердження
видалення кожного файлу.

```bash
$ rm -i file1 file2
rm: remove regular empty file `file1'? y
rm: remove regular empty file `file2'? y
```

У останньому прикладі перед видаленням кожного файлу команда `rm` запитує: чи дійсно
користувач хоче видалити файл? Щоб підтвердити видалення, потрібно натиснути клавішу <kbd>y</kbd> на клавіатурі, а щоб відмовитися — клавішу <kbd>n</kbd>. Прервати виконання будь-якої команди
(якщо щось пішло не так) можна, натиснувши комбінацію <kbd>Ctrl+C</kbd>. Щоб команда `rm`
запитувала підтвердження на видалення кожного файлу навіть без опції `-i`, можна додати
в файл `~/.bashrc` за допомогою улюбленого текстового редактора рядок:

```bash
alias rm="rm -i"
```

#### `rmdir`

Є два способи видалення директорій: можна поетапно видалити все вміст директорії, а потім використати команду `rmdir` для видалення самої директорії:

```bash
$ mkdir mydir
$ touch mydir/file1
$ rm mydir/file1
$ rmdir mydir
```

Цей спосіб зазвичай називають "метод видалення директорій для невдах". Набагато зручніше в
икористовувати команду `rm -rf` для видалення директорії з усім її вмістом.

```bash
$ rm -rf mydir
```

Цю команду потрібно використовувати з обережністю, оскільки за її допомогою
адміністратору (тим більше з правами адміністратора) без досвіду дуже легко видалити
вміст з усього жорсткого диска.

### Жорсткі посилання

Слово "посилання" вже згадувалося, коли розглядалися директорії та inode. Насправді в
Linux існує два види посилань. Перший вид називають жорсткими посиланнями. Кожен inode
може мати кілька пов’язаних з ним жорстких посилань. Таким чином, файл може існувати в
системі під кількома різними іменами. Файл існує доти, поки з його inode пов’язане хоча б
одне ім’я. Поняття «жорстке посилання на файл» і «ім’я файлу» є синонімами. Нові жорсткі
посилання на файл можна створити за допомогою команди `ln`:

```bash
$ cd /tmp
$ touch firstlink
$ ln firstlink secondlink
$ ls -i firstlink secondlink
15782 firstlink    15782 secondlink
```

Як видно з прикладу, жорсткі посилання працюють на рівні inode, вказуючи на певний файл.
В Linux у жорстких посилань є кілька обмежень. По-перше, можна створювати жорсткі
посилання лише на файли, а не на директорії. Хоча в системі існують жорсткі посилання на
директорії (`.` і `..`), навіть суперкористувач не може створювати додаткові жорсткі
посилання на директорії. По-друге, неможливо створити жорстке посилання на файл, що
знаходиться в іншій файловій системі, оскільки кожна файлові система має свій унікальний
набір inode.

### Символічні посилання

На практиці частіше використовують символічні посилання (або симлінки). Симлінк — це
спеціальний вид файлу, який посилається на інший файл за його іменем, а не безпосередньо
на inode. Симлінки не захищають файл від видалення. Якщо файл видалити, то симлінк на
нього стане неробочим (або "битим"). Симлінки створюються командою `ln` з опцією `-s`:

```bash
$ ln -s secondlink thirdlink
$ ls -l firstlink secondlink thirdlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 firstlink
-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 secondlink
lrwxrwxrwx    1 agriffis agriffis       10 Dec 31 19:39 thirdlink -> secondlink
```

Символічне посилання можна розпізнати за виводом команди `ls -l`: по-перше, в першій
колонці для симлінків стоїть буква 'l' (перша буква англійського слова "link"); по-друге,
розмір симлінка дорівнює кількості букв в імені файлу, на який він посилається (в нашому
випадку — `secondlink`); по-третє, в останній колонці, окрім імені посилання, міститься
ім'я файлу, на який воно посилається, після знака `->`.

Символічні посилання значно гнучкіші за жорсткі. З їх допомогою можна посилатися на будь-
який об'єкт (файл, директорію, сокет тощо) будь-якої файлової системи.

Розглянемо ситуацію, коли потрібно зробити симлінк, який вказує на `/usr/local/bin` і
знаходиться в директорії `/tmp/`:

```bash
$ ln -s /usr/local/bin bin1
$ ls -l bin1
lrwxrwxrwx    1 root     root           14 Jan  1 15:42 bin1 -> /usr/local/bin
```

або

```bash
$ ln -s ../usr/local/bin bin2
$ ls -l bin2
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin
```

Як видно з цих прикладів, обидва посилання вказують на одну директорію. Але якщо друге
посилання перемістити з `/tmp` в іншу директорію, воно може стати "битим" через
використаний у ньому відносний шлях:

```bash
$ ls -l bin2
lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin
$ mkdir mynewdir
$ mv bin2 mynewdir
$ cd mynewdir
$ cd bin2
bash: cd: bin2: No such file or directory
```

Оскільки не існує директорії `/tmp/usr/local/bin/`, неможливо перейти в робочу директорію
`bin2;` іншими словами, після переміщення посилання перестало працювати (стало "битим").
Через це іноді варто уникати створення симлінків з використанням відносних шляхів. Але
іноді це може бути зручним.

Розглянемо приклад, коли потрібно зробити посилання на програму в `/usr/bin` (тобто
надати цій програмі альтернативну назву):

```
# ls -l /usr/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
```

Суперкористувач (root) може захотіти зробити посилання на програму "keychain" з більш
коротким ім'ям "kc". У цьому прикладі у нас є root-доступ до системи, про що свідчить
запрошення bash, що змінилося на "#". Права суперкористувача також потрібні, оскільки
звичайні користувачі не можуть створювати файли в директорії `/usr/bin/`. Тепер можна від
імені root створити альтернативне ім'я для `keychain`:

```
# cd /usr/bin
# ln -s /usr/bin/keychain kc
# ls -l keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
# ls -l kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain
```

У цьому прикладі було створено симлінк `kc`, який посилається на файл `/usr/bin/
keychain`. Це посилання повністю робоче, але вонo перестане працювати, якщо перемістити
обидва файли `keychain` і `kc` з директорії `/usr/bin/` в `/usr/local/bin/`:

```
# mv /usr/bin/keychain /usr/bin/kc /usr/local/bin
# ls -l /usr/local/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# ls -l /usr/local/bin/kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain
```

Оскільки при створенні посилання був використаний абсолютний шлях, воно продовжує
вказувати на файл `/usr/bin/keychain`, якого більше немає. Але якщо б використовувався
відносний шлях при створенні посилання, воно залишилося б робочим.

Таким чином, посилання, створені з абсолютними і відносними шляхами, мають своє
застосування. Тому при створенні симлінка потрібно вибрати спосіб, який буде доцільнішим
у даній ситуації. Часто обидва види симлінків (з абсолютними і відносними шляхами)
працюють нормально. Наступний приклад демонструє спосіб створення симлінка, який
продовжує працювати після переміщення його та файлу, на який він посилається, в іншу
директорію:

```
# cd /usr/bin
# ln -s keychain kc
# ls -l kc
lrwxrwxrwx    1 root     root            8 Jan  5 12:40 kc -> keychain
# mv keychain kc /usr/local/bin
# ls -l /usr/local/bin/keychain
-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
# ls -l /usr/local/bin/kc
lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> keychain
```

Тепер можна запускати програму `keychain`,
звертаючись до неї за іменем `/usr/local/bin/kc`.

### Використання шаблонів (wildcards)

У повсякденному використанні часто виникають ситуації, коли потрібно виконати одну просту
операцію (наприклад, `rm`) над багатьма файлами. У такому випадку не дуже зручно
перераховувати всі імена файлів у командному рядку:

```bash
$ rm file1 file2 file3 file4 file5 file6 file7 file8
```

Цю проблему можна вирішити за допомогою шаблонів заміни (wildcards). Командний
інтерпретатор підтримує можливість вказання кількох файлів, використовуючи шаблони (з
історичних причин це також називають "globbing"). Bash і інші команди вибирають лише ті
файли, які збігаються з шаблоном.

Наприклад, якщо потрібно видалити файли з `file1` по `file8`, можна написати:

```bash
$ rm file[1-8]
```

А якщо потрібно видалити всі файли, імена яких починаються зі слова `file`, можна
використовувати:

```bash
$ rm file*
```

Шаблон `*` відповідає будь-якому символу, послідовності символів або "відсутності
символу". Звичайно, шаблони можна застосовувати не лише для видалення файлів, як буде
показано нижче.

Якщо необхідно вивести список файлів у директорії `/etc/`, імена яких починаються з
літери "g" (і файл з ім'ям "g", якщо такий існує), потрібно написати:

```bash
$ ls -d /etc/g*
```

Це може вивести щось на кшталт:

```
/etc/gconf  /etc/ggi  /etc/gimp  /etc/gnome  /etc/gnome-vfs-mime-magic  /etc/gpm  /etc/group  /etc/group-
```

Давайте подивимося, що станеться, якщо вказати шаблон, який не збігається з жодним іменем
файлу:

```bash
$ ls -d /usr/bin/asdf*jkl
ls: /usr/bin/asdf*jkl: No such file or directory
```

У цьому прикладі ми намагалися вивести список файлів, імена яких починаються на "asdf" і
закінчуються на "jkl". Командний інтерпретатор видав повідомлення, що файлів з такими
іменами не знайдено.

#### Синтаксис шаблона: `*` і `?`

Ми розглянули, як працює глоббінг (підстановка імен файлів). Тепер розглянемо детальніше
синтаксис шаблонів:

- **`*`** відповідає нулю або більшій кількості символів:

  - `/etc/g*` — всі файли в директорії `/etc/`, імена яких починаються з "g" (включаючи
    файл з ім'ям "g").
  - `/tmp/my*1` — всі файли в директорії `/tmp/`, імена яких починаються з "my" і
    закінчуються на "1" (включаючи файл з ім'ям "my1").

- **`?`** замінює один будь-який символ:
  - `myfile?` — будь-який файл, чиє ім'я починається зі слова "myfile", за яким слідує
    один будь-який символ.
  - `/tmp/notes?txt` — відповідає файлам з іменами "notes.txt" та "notes_txt" (якщо вони
    існують у `/tmp/`).

Ці шаблони дозволяють зручно працювати з групами файлів, спрощуючи виконання команд.

#### Квадратні дужки: `[]`

Шаблон `[]` дуже схожий на `?`, але дозволяє явно вказувати набір символів. Шаблон `[]`
відповідає одному символу з тих, що вказані в дужках. Також у дужках можна вказувати
діапазон символів (для цього використовується символ дефісу), або кілька діапазонів
підряд. Тоді шаблон буде відповідати будь-якому символу з цього діапазону:

- `myfile[12]` — відповідає `myfile1` і `myfile2`. Шаблон буде працювати, поки існує хоча
  б один з цих двох файлів.
- `[Cc]hange[Ll]og` — відповідає файлам з іменами `Changelog`, `ChangeLog`, `changeLog` і
  `changelog`. Як ви могли помітити, використання шаблону `[]` корисно при пошуку імен, що
  відрізняються регістром букв.

Декілька прикладів використання шаблонів:

- `ls /etc/[0-9]*` — виведе список файлів у директорії `/etc/`, імена яких починаються з цифри.
- `ls /tmp/[A-Za-z]*` — виведе список файлів у директорії `/tmp/`, імена яких починаються з букви (велика або мала).

Конструкція `[[]]` схожа на `[]`, за винятком того, що вона відповідає одиничному символу, не згаданому між `[[` і `]`. Наприклад:

```bash
rm myfile[[9]
```

Ця команда видалить всі файли, імена яких складаються зі слова "myfile" і однієї цифри, за винятком файлу "myfile9".

Розглянемо декілька прикладів використання шаблонів.
Оскільки `bash` інтерпретує символи `?`, `[`, `]`, `*` як шаблони заміни, потрібно бути
обережним при використанні аргументів, що містять ці символи. Наприклад, якщо ви хочете
створити файл, що містить рядок `[fo]*`, то така команда може зробити не те, що ви
очікуєте:

```bash
$ echo [fo]* > /tmp/mynewfile.txt
```

Якщо в робочій директорії знайдеться один або кілька файлів, імена яких відповідають
шаблону `[fo]*`, то в `/tmp/mynewfile.txt` буде список їхніх імен, а не рядок `[fo]*`.

Існує кілька способів записати цей рядок у файл:

1. Використати одинарні лапки:

   ```bash
   $ echo '[fo]*' > /tmp/mynewfile.txt
   ```

   Після виконання цієї команди файл буде містити рядок `[fo]*`, як і очікувалося.

2. "Екранувати" спеціальні символи за допомогою зворотного слеша (`\`):

   ```bash
   $ echo \[fo\]\* > /tmp/mynewfile.txt
   ```

Обидва запропоновані методи (одинарні лапки і екранування) дають бажаний результат. Щоб
вказати текстовий символ `"`, можна або взяти його в одинарні лапки, або написати `\"`.

**Застереження:** Подвійні лапки працюють майже так само, як і одинарні, але дозволяють
`bash` інтерпретувати деякі спеціальні символи. Тому одинарні лапки — найкращий спосіб
передати команді лише текст. Для додаткової інформації про шаблони читайте справку `man 7 
glob`. Для додаткової інформації про використання лапок, читайте розділ QUOTING справки
`man 8 glob`.

### Команди `find` і `grep`

#### `find`

Для пошуку файлів і каталогів використовується команда `find`.

_Пошук за назвою._
Для того щоб знайти файл `views.py`, який розташований десь під
директорією `./my-first-blog` достатньо ввести команду:

```bash
$ find ./my-first-blog -name "views.py"
./my-first-blog/blog/views.py
```

Параметр `-name` вказує на файл з конкретним ім'ям. Якщо замість `-name` вказати
`-iname`, то буде виконано пошук з ігноруванням регістру.

Звісно можна використовувати синтаксис шаблонів:

```bash
$ find ./my-first-blog -name "*init*"
./my-first-blog/mysite/__init__.py
./my-first-blog/blog/migrations/__init__.py
./my-first-blog/blog/migrations/0001_initial.py
./my-first-blog/blog/__init__.py
```

_Пошук за типом_. Припустимо, що нас цікавлять лише директорії, тоді
ми можемо додати параметр `-type`, вказавши тип `d`:

```bash
$ find ./my-first-blog -name "blog" -type d
./my-first-blog/blog
./my-first-blog/blog/templates/blog
```

Типу `f` відповідає звичайний файл, `l` — символічне посилання.

_Пошук за розміром._ Іноді буває потрібно знайти файли (або директорії),
які займають багато місця на диску. Ось приклад команди, яка шукає файли, розмір
яких перевищує 10 МБ:

```bash
$ find ~/Documents -type f -size +10M
```

Також можна здійснити пошук за датою модифікації за допомогою параметра `-mtime` або
передавати знайдені файли по одному як аргументи іншим командам, використовуючи
`-exec`.

#### `grep`

Команда `grep` дозволяє шукати текстову інформацію у файлах та потоках виводу Linux. Це
надзвичайно зручний інструмент. Наприклад, коли ви відкриваєте незнайомий проект і вам
потрібно щось виправити, ви можете швидко знайти потрібний фрагмент у вихідному коді та
зрозуміти, де знаходиться потрібна логіка.

Ось класичний спосіб використання `grep`:

```bash
$ grep -rin --include="*.py" "an error occurred" .
```

Тут ми викликаємо команду `grep`, яка шукатиме текст
"an error occurred" у файлах, назви яких закінчуються на `.py`.

Щоб вказати, як і де шукати, ми передаємо параметри:

- `r` — рекурсивний пошук, тобто в директорії та всіх її піддиректоріях.
- `i` — пошук з ігноруванням регістру, тобто будуть знайдені як "Error", так і "error", і "ERROR".
- `n` — ми хочемо виводити не тільки знайдені рядки, але й їх номери, щоб зручно відкрити файл у текстовому редакторі, що підтримує автоматичне відображення номерів рядків.

Додатковий параметр `--include="*.py"` якраз і говорить `grep`, що нас цікавлять лише
файли, що закінчуються на `.py`.

Точка в кінці команди означає, що ми хочемо шукати в поточній директорії. Якщо б ми
хотіли шукати в директорії `/tmp`, то замість крапки вказали б `/tmp`:

```bash
$ grep -rin --include="*.py" "an error occurred" /tmp/
```

Ці параметри є опціональними. Наприклад, ми можемо шукати і так:

```bash
$ grep "an error occurred" /tmp/
```

якщо ми хочемо шукати тільки в директорії `/tmp`, але не в її піддиректоріях, нам не
потрібні номери знайдених рядків, регістр тексту саме той, що ми задали, а нас цікавлять
файли з будь-яким розширенням, не тільки з Python-кодом.

Дуже зручно за допомогою символа `|` перенаправляти вивід команди `find` в `grep`:

```bash
$ find ./my-first-blog -iname '*.py' | grep 'settings'
./my-first-blog/mysite/settings.py
```

або в `less`:

```bash
$ find ./my-first-blog -iname "*.py" | less
```

Команда `less`, як уже зазначалося в кінці параграфa про
[Перенаправлення вводу-виводу](#перенаправлення-вводу-виводу),
дозволяє в інтерактивному режимі продивлятися
вивід інших команд.
Щоб вийти з режиму перегляду, потрібно натиснути клавішу <kbd>q</kbd>.

### Команда `man`

Під час використання операційної системи Linux вам часто буде потрібно отримати
інформацію про те, що робить та чи інша команда або системний виклик, які в них параметри
та опції, для чого призначені певні системні файли, який їх формат тощо. Отримати цю
інформацію можна за допомогою утиліти `man`:

```bash
man <name>
```

де `name` — це назва команди, утиліти, системного виклику, бібліотечної функції або файлу.

Наприклад:

```bash
man echo
```

Щоб вийти з `man`, натисніть клавішу <kbd>q</kbd>.

Іноді імена команд інтерпретатора та системних викликів або якісь інші імена можуть збігатися. У такому випадку, щоб знайти потрібну інформацію, потрібно вказати утиліті `man` категорію, до якої належить інформація (номер розділу). Поділ інформації за категоріями може трохи відрізнятися для різних версій UNIX. У Linux, наприклад, прийнятий наступний розподіл:

1. Виконувані файли або команди інтерпретатора.
2. Системні виклики.
3. Бібліотечні функції.
4. Спеціальні файли (зазвичай файли пристроїв).
5. Формат системних файлів і прийняті угоди.
6. Ігри (зазвичай відсутні).
7. Макропакети та утиліти, такі як сам `man`.
8. Команди системного адміністратора.
9. Підпрограми ядра (нестандартний розділ).

Якщо ви знаєте розділ, до якого належить інформація, то утиліту `man` можна викликати в Linux з додатковим параметром:

```bash
man <номер_розділу> <name>
```

У інших операційних системах цей виклик може виглядати інакше. Щоб отримати точну інформацію про розбиття на розділи, форму вказівки номера розділу та додаткові можливості утиліти `man`, наберіть команду:

```bash
man man
```

## Текстові редактори

### Vim

<!-- TODO:  додати короткий та вичерпний опис по роботі в vim -->

**Vim** (скорочено від Vi Improved, вимовляється Вім) — текстовий редактор, створений на основі більш старого Vi. Нині це один із найпотужніших текстових редакторів з повною свободою налаштування та автоматизації.

### Nano

GNU nano — це невеликий і простий текстовий редактор. Він має
підсвічування синтаксису, перевірку орфографії, вирівнювання, завершення,
скасування/повторення тощо.

## Змінні середовища

### Маніпуляції зі змінними

Змінні середовища в Linux — це набір пар `ЗМІННА=ЗНАЧЕННЯ`, які можуть використовуватися програмами під час виконання. Це зручно, коли програма "вгадує" ім’я користувача або домашній каталог користувача. Найчастіше така інформація "добувається" з змінних середовища `USER` та `HOME` відповідно. Змінні можуть визначатися системою та користувачем.

Системні змінні середовища Linux визначаються системою та використовуються програмами системного рівня. Користувацькі змінні середовища встановлюються користувачем для поточної shell, тимчасово або постійно. Змінні середовища можуть формуватися як з великих, так і з малих символів, однак історично склалося, що їх називають великими літерами. Значення кожної змінної середовища спочатку є рядковою константою (рядком).

Командні оболонки, такі як `bash`, мають власний набір пар `ЗМІННА=ЗНАЧЕННЯ` — це змінні оболонки (shell). Набір таких змінних називають середовищем оболонки. Ці змінні чимось нагадують локальні змінні в мові програмування C. Вони недоступні для інших програм і використовуються в основному в сценаріях shell. Щоб задати змінну shell, достатньо написати в командному рядку:

```
ЗМІННА=ЗНАЧЕННЯ
```

#### Перегляд

Щоб переглянути список змінних, визначених у поточній shell, запустіть у терміналі команду:

```
$ set | less
```

Щоб переглянути список змінних, доступних іншим програмам, запустіть `env`:

```
$ env | less
```

Відмінність команди `env` від команди `set` полягає в тому, що команда `set` виводить список усіх змінних середовища, включаючи ті, які не експортуються в дочірні командні shell.

#### Додавання нових змінних

Щоб додати змінну в середовище, потрібно виконати конструкцію:

```
$ LOCAL_VAR="Hello World"
```

Перевірка змінної

```
$ echo $LOCAL_VAR
Hello World
$ env | grep LOCAL_VAR
$ set | grep LOCAL_VAR
'Hello World'
```

При бажанні можна включити локальну змінну shell в основне середовище за допомогою команди `export`:

```
$ export LOCAL_VAR
$ env | grep LOCAL_VAR
LOCAL_VAR=Hello World
```

Можна зробити це відразу:

```
$ export ENV_VAR=Bye
$ echo $ENV_VAR
Goodbye
$ env | grep ENV_VAR
ENV_VAR=Bye
```

Інтерпретація значень змінних повністю покладається на програму. Щоб вивести на екран значення якоїсь змінної середовища, достатньо ввести:

```
$ echo $USER
user
```

За замовчуванням за допомогою `env` можна переглянути всі встановлені змінні середовища. Але з опцією `-i` вона дозволяє тимчасово видалити всі змінні shell та виконати команду без змінних:

```
$ env -i [Var=Value] <command>
```

`Var` — це будь-яка змінна, яку ви хочете передати цій команді. Наприклад, така команда запустить shell взагалі без змінних середовища:

```
$ env -i bash
```

Після запуску такого середовища не буде доступно жодних змінних, але після виходу все повернеться на свої місця.

#### Видалення змінних

Існує інший спосіб видалення змінних середовища в Linux — команда `unset`, яка видаляє змінну за іменем до кінця поточної сесії:

```
unset <VAR_NAME>
```

Приклад:

```
$ export ENV_VAR=Bye
$ echo $ENV_VAR
Goodbye
$ env | grep ENV_VAR
ENV_VAR=Bye
$ unset ENV_VAR
$ env | grep ENV_VAR
```

### PATH

В Linux `$PATH` — це змінна середовища, яка використовується для вказівки shell, де шукати виконувані файли. `$PATH` забезпечує велику гнучкість і безпеку для систем Linux, і, безумовно, можна сказати, що це одна з найважливіших змінних середовища.

Програми/скрипти, розташовані в каталозі `$PATH`, можуть бути виконані безпосередньо у вашій shell без вказівки повного шляху до них. Подивимося на поточне значення `$PATH`:

```
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games/
```

У результаті виводиться список каталогів, розділених двокрапками. Під час пошуку shell переглядає каталоги саме в тому порядку, в якому вони перераховані у змінній `$PATH`. Щоб додати нову директорію, необхідно виконати команду:

```
$ PATH=$PATH:<path_to_directory>
```

або

```
$ PATH=<path_to_directory>:$PATH
```

У першому випадку пошук у доданій директорії буде відбуватися в останню чергу (тільки якщо виконуваний файл не знайдений у директоріях, перерахованих в початковому значенні `$PATH`), у другому випадку — спочатку в доданій директорії, а потім в початковому значенні `$PATH`.

Варто зазначити, що можна включити в цей список і поточний каталог, додавши в змінну `$PATH` крапку. Проте цього не рекомендується робити з міркувань безпеки: зловмисник може помістити в загальнодоступний каталог команду, ім'я якої збігається з однією з часто виконуваних суперкористувачем команд, але яка виконує зовсім інші дії (особливо якщо поточний каталог стоїть на початку списку шляхів пошуку).

## Профіль користувача, групи, права доступу

Для входу в операційну систему UNIX кожен користувач повинен бути зареєстрований у ній під певним ім’ям. Усі користувачі в системі діляться на групи користувачів. Наприклад, усі студенти однієї навчальної групи можуть складати свою власну групу користувачів. Групи користувачів також отримують свої імена. Для отримання інформації про активних користувачів існує кілька команд:

- **users** — виводить інформацію про користувачів, підключених до системи в даний момент.
- **w** — список користувачів, підключених до системи: віртуальний термінал, з якого працює користувач; час входу в систему для кожного користувача, статистику використання системи (IDLE — час простою, JCPU — використання процесора), виконувані кожним користувачем завдання.
- **who** — список користувачів, підключених до системи; час і дата входу кожного користувача.
- **whoami** — ім’я користувача, який ввів команду.
- **ps** — видає інформацію про активні процеси. За замовчуванням інформація надається тільки про процеси, асоційовані з даним терміналом. Виводяться ідентифікатор процесу, ідентифікатор термінала, витрачений на даний момент час ЦП та ім’я команди. Якщо потрібна інша інформація, слід скористатися опцією `-e`.

Для кожного файлу, створеного у файловій системі, запам’ятовуються імена його власника та групи власників. Зазначимо, що група власників не обов’язково повинна бути групою, до якої входить власник. В операційній системі Linux при створенні файлу його власником стає користувач, який створив файл, а його групою власників — група, до якої він належить. В подальшому власник файлу або системний адміністратор можуть передати його у власність іншому користувачу або змінити його групу власників за допомогою команд `chown` та `chgrp`, опис яких можна знайти в UNIX Manual.

Таким чином, для кожного файлу виділяється три категорії користувачів:

1. Користувач, який є власником файлу.
2. Користувачі, які належать до групи власників файлу.
3. Усі інші користувачі.

Для кожної з цих категорій користувачів власник файлу може визначити різні права
доступу до файлу, використовуючи команду `chmod`. Розрізняють три види прав доступу:
право на читання файлу — `r` (read), право на модифікацію файлу — `w` (write) та
право на виконання файлу — `x` (execute). Для регулярних файлів зміст цих прав
збігається з зазначеним вище. Для директорій він трохи змінюється. Право читання для
каталогів дозволяє читати імена файлів, що знаходяться в цьому каталозі (і тільки
імена). Оскільки "виконувати" директорію безглуздо (як, втім, і не виконуваний
регулярний файл), право доступу на виконання для директорій змінює зміст: наявність
цього права дозволяє отримати додаткову інформацію про файли, що входять до каталогу:
їхній розмір, хто їхній власник, дата створення тощо. Право на виконання також
потрібно для директорії, щоб зробити її поточною, а також для всіх директорій по
шляху до зазначеної. Право запису для директорії дозволяє змінювати її вміст:
створювати і видаляти в ній файли, перейменовувати їх. Зазначимо, що для видалення файлу достатньо мати право запису для директорії, в яку безпосередньо входить даний
файл, незалежно від прав доступу до самого файлу.

### chmod

```
$ chmod опції права <path_to_file>
```

Існує два способи задання прав: символьний і числовий. У числовому вигляді файлу або каталогу встановлюються абсолютні права, в той час як у символьному вигляді можна змінити окремі права для різних типів користувачів.

У символьному вигляді опції описують операції, які потрібно виконати над правами користувачів і мають вид [references][operator][modes].

**References** визначають користувачів, яким будуть змінюватися права. References визначаються однією або кількома буквами:

- **u (user)** - Власник файлу
- **g (group)** - Користувачі, що входять у групу власника файлу
- **o (others)** - Інші користувачі
- **a (all)** - Всі користувачі (або ugo)

**Operator** визначає операцію, яку буде виконувати `chmod`:

- **+** - додати певні права
- **-** - видалити певні права
- **=** - встановити певні права

**Modes** визначають, які саме права будуть встановлені, додані або видалені:

- **r (read)** - читання файлу або вмісту каталогу
- **w (write)** - запис у файл або в каталог
- **x (execute)** - виконання файлу або читання вмісту каталогу

Наприклад:

Установити права на читання і виконання для власника файлу, видалити права на виконання у групи, видалити права на запис і виконання у інших користувачів:

```
$ chmod u+rx,g-x,o-wx <filename>
```

У числовому вигляді права задаються у вигляді тризначного числа, кожна цифра якого задає права файлу для певної категорії користувачів — перша для власника, друга — для групи, третя — для інших.

### Варіанти запису прав користувача

| Двоїчна | Восьмерична | Символьна |
| ------- | ----------- | --------- |
| 000     | 0           | `---`     |
| 001     | 1           | `--x`     |
| 010     | 2           | `-w-`     |
| 011     | 3           | `-wx`     |
| 100     | 4           | `r--`     |
| 101     | 5           | `r-x`     |
| 110     | 6           | `rw-`     |
| 111     | 7           | `rwx`     |

Таким чином, `chmod 755 filename` означає права `rwxr-xr-x`:

|                             | Власник | Група | Інші  |
| --------------------------- | ------- | ----- | ----- |
| Восьмеричне значення        | 7       | 5     | 5     |
| Символьний запис            | `rwx`   | `r-x` | `r-x` |
| Позначення типу користувача | u       | g     | o     |

### Розповсюджені значення:

- `400` `(-r--------)`. Власник має право читання; ніхто інший не має права виконувати ніякі дії.
- `644` `(-rw-r--r--)`. Усі користувачі мають право читання; власник може редагувати.
- `660` `(-rw-rw----)`. Власник і група можуть читати і редагувати; інші не мають права виконувати ніякі дії.
- `664` `(-rw-rw-r--)`. Усі користувачі мають право читання; власник і група можуть редагувати.
- `666` (-rw-rw-rw-). Усі користувачі можуть читати і редагувати.
- `700` `(-rwx------)`. Власник може читати, записувати і виконувати; ніхто інший не має права виконувати ніякі дії.
- `744` `(-rwxr--r--)`. Кожен користувач може читати; власник має право редагувати і виконувати.
- `755` `(-rwxr-xr-x)`. Кожен користувач має право читати і виконувати; власник може редагувати.
- `777` `(-rwxrwxrwx)`. Кожен користувач може читати, редагувати і виконувати.

### Foreground і Background процеси

Запущений процес в звичайному режимі працює в режимі **“foreground”**, тобто – “на передньому плані” або, іншими словами, “в пріоритетному режимі”. У такому режимі він приймає команди з керуючого термінала, в якому він запущений, і на нього ж виводиться інформація `stdout` і `stderr`. Крім того, він робить недоступним командний рядок.

Щоб запустити задачу у фоновому режимі, в кінці команди необхідно додати знак `&`, наприклад:

```
$ tar cpf usr.lib.tar usr/lib 2>/dev/null &
[1] 55887
```

Відобразити список поточних фоновых задач можна командою `jobs`, наприклад:

```
$ jobs
[6]-  Stopped                 top
[7]+  Stopped                 tar
```

Другий спосіб – запустити її в звичайному режимі, після чого натиснути комбінацію <kbd>Ctrl+Z</kbd>. Після цього вона з'явиться в списку `jobs` з новим номером:

```
$ tar cpf usr.lib.tar usr/lib 2>/dev/null
^Z
[2]+  Stopped                 tar cpf usr.lib.tar usr/lib 2>/dev/null &
```

Тепер, щоб продовжити її виконання в фоновому режимі, введіть команду `bg` (background):

```
$ bg
[2]+      tar cpf usr.lib.tar usr/lib 2>/dev/null &
```

Команда `jobs` завжди викликається без аргументів і показує завдання, запущені з
поточного екземпляра shell. На початку кожного рядка виводу цієї команди вказується
порядковий номер завдання у вигляді числа в квадратних дужках. Після номера вказується
стан процесу: `stopped` (остановлений), `running` (виконується) або `suspended`
(приостановлений). В кінці рядка вказується команда, яка виконується цим процесом. Одне
з номерів виконуваних завдань позначено знаком `+`, а ще одне — знаком `-`. Процес,
позначений знаком `+`, буде за замовчуванням вважатися аргументом команд `fg` або `bg`,
якщо вони викликаються без параметрів. Процес, позначений знаком `-`, отримає знак `+`,
якщо завершиться з якоїсь причини процес, який був позначений знаком `+`.

Щоб вивести задачу з фонового режиму, використовується команда `fg` (foreground), якій
можна або передати номер задачі в якості аргумента, або – запустити без аргументів. У
останньому випадку – буде виведена задача, відмічена знаком `+` у списку `jobs`, тобто
– остання “фонова” задача.

Наприклад, команда (у випадку, якщо `top` знаходиться в фоні з номером задачі 6):

```
$ fg 6
```

Поверне на екран утиліту `top` і переведе її в режим **Running**.

### Сигнали і команда kill

Сигнали — це засіб, за допомогою якого процесам можна передавати повідомлення про певні
події в системі. Сами процеси також можуть генерувати сигнали, за допомогою яких вони
передають певні повідомлення ядру та іншим процесам. За допомогою сигналів можна
виконувати такі дії управління процесами, як призупинення процесу, запуск призупиненого
процесу, завершення роботи процесу. Всього в Linux існує 63 різних сигнала, їх перелік
можна переглянути за командою:

```
$ kill -l
```

Сигнали прийнято позначати номерами або символічними іменами. Усі імена починаються на
`SIG`, але цю приставку іноді опускають: наприклад, сигнал з номером 1 позначають або
як `SIGHUP`, або просто як `HUP`.

Коли процес отримує сигнал, можливий один з двох варіантів розвитку подій. Якщо для
даного сигналу визначена підпрограма обробки, то викликається ця підпрограма. В іншому
випадку ядро виконує від імені процесу дію, визначену за замовчуванням для цього
сигналу. Виклик підпрограми обробки називається перехопленням сигналу. Коли
завершується виконання підпрограми обробки, процес відновлюється з тієї точки, де був
отриманий сигнал.

Можна змусити процес ігнорувати або блокувати деякі сигнали. Ігнорований сигнал просто відкидається процесом і не має на нього жодного впливу. Блокований сигнал ставиться в
чергу на видачу, але ядро не вимагає від процесу жодних дій до розблокування сигналу.
Після розблокування сигналу програма його обробки викликається лише один раз, навіть
якщо протягом періоду блокування цей сигнал надходив кілька разів.

#### Список деяких із часто зустрічаючихся сигналів

| №   | Ім'я | Опис                                                                                                                                                                                              | Перехоплюється | Блокується | Комбінація клавіш                    |
| --- | ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------- | ------------------------------------ |
| 1   | HUP  | Сигнал, що надсилається процесу для сповіщення про втрату з'єднання з керуючим терміналом користувача                                                                                             | Так            | Так        |                                      |
| 2   | INT  | Interrupt. У випадку виконання простих команд викликає припинення виконання; в інтерактивних програмах — припинення активного процесу                                                             | Так            | Так        | <kbd>Ctrl+C</kbd> або <kbd>Del</kbd> |
| 3   | QUIT | Сигнал, для зупинки процесу користувачем. Також вказує, що система повинна виконати дамп пам'яті для процесу                                                                                      | Так            | Так        | <kbd>Ctrl+\\</kbd>                   |
| 4   | ILL  | Illegal Instruction. Центральний процесор зіткнувся з незнайомою командою (в більшості випадків це означає, що допущена програмна помилка). Сигнал надсилається програмі, в якій виникла проблема | Так            | Так        |                                      |
| 8   | FPE  | Floating Point Exception. Обчислювальна помилка, наприклад, ділення на нуль                                                                                                                       | Так            | Так        |                                      |
| 9   | KILL | Завжди припиняє виконання процесу                                                                                                                                                                 | Ні             | Ні         |                                      |
| 11  | SEGV | Segmentation Violation. Доступ до недозволеної області пам'яті                                                                                                                                    | Так            | Так        |                                      |
| 15  | TERM | Software Termination. Вимога закінчити процес (програмне завершення)                                                                                                                              | Так            | Так        |                                      |
| 17  | CHLD | Зміна статусу породженого процесу                                                                                                                                                                 | Так            | Так        |                                      |
| 18  | CONT | Продовження виконання призупиненого процесу                                                                                                                                                       | Так            | Так        |                                      |
| 19  | STOP | Призупинення виконання процесу                                                                                                                                                                    | Ні             | Ні         |                                      |
| 20  | TSTR | Сигнал зупинки, генерований клавіатурою. Переводить процес у фоновий режим                                                                                                                        | Так            | Так        | <kbd>Ctrl+Z</kbd>                    |

Як видно з опису, деякі сигнали можна згенерувати за допомогою певних комбінацій
клавіш. Але такі комбінації існують не для всіх сигналів. Зате є команда `kill`, яка
дозволяє надіслати заданому процесу будь-який сигнал. Як вже було сказано, за допомогою
цієї команди можна отримати список усіх можливих сигналів, якщо вказати опцію `-l`.
Якщо після цієї опції вказати номер сигналу, то буде видане його символічне ім'я, а
якщо вказати ім'я, то отримаємо відповідний номер.

Для надсилання сигналу процесу (або групі процесів) можна скористатися командою `kill`
у наступному форматі:

```
$ kill [-signal] PID [PID..]
```

де `signal` — це номер сигналу, причому якщо вказування сигналу опущено,
то надсилається сигнал 15 (TERM — програмне завершення процесу).
Найчастіше використовується
сигнал 9 (KILL), за допомогою якого суперкористувач може завершити будь-
який процес.
Але цей сигнал дуже "грубий", якщо можна так висловитися, тому його
використання може
призвести до порушення порядку в системі. Тому в більшості випадків
рекомендується
використовувати сигнали TERM або QUIT, які завершають процес більш "м'яко".

Звісно, що найчастіше команду `kill` змушений застосовувати суперкористувач. Він
повинен використовувати її для знищення процесів-зомбі, завислих процесів (вони
показуються в списку команди `ps` як `<exiting>`), процесів, які займають занадто
багато процесорного часу або занадто великий обсяг пам'яті тощо.

### Скрипти

### Shell скрипти

Команди, що виконуються в bash, також можна записати у файл і запускати на виконання. Для цього потрібно створити файл (зазвичай з розширенням `.sh`, наприклад, `script.sh`), у першому рядку вказавши інтерпретатор, який буде виконувати команди, у нашому випадку це:

```bash
#!/bin/bash
```

і далі помістити виконувані команди.

Наприклад:

```bash
#!/bin/bash
pwd
ls -al
```

Щоб файл можна було запускати, встановимо йому атрибут виконання за допомогою команди `chmod`:

```bash
$ chmod a+x ./script.sh
```

і далі запустимо:

```bash
$ ./script.sh
...
```

В результаті роботи скрипта на екран спочатку буде виведена поточна директорія, а потім її вміст.

Щоб програма, яка викликає скрипт, могла проаналізувати результат його виконання, існує такий термін, як код повернення, який доступний програмі, що викликається.
Наприклад:

```bash
$ ls
<вміст каталогу>
$ echo $?
0
```

Нульовий код повернення означає, що викликана команда (або скрипт) виконалися коректно. Спробуємо вивести вміст неіснуючої директорії:

```bash
$ ls /abc
ls: /abc: No such file or directory
$ echo $?
1
```

Як ми бачимо, в результаті команда `ls` повернула код помилки 1.

Кожна команда повертає код завершення (іноді код завершення називають
повертаємим значенням). У випадку успіху команда повинна повертати 0, а у
випадку помилки — ненульове значення, яке, як правило, інтерпретується як
код помилки. Практично всі команди та утиліти UNIX повертають 0 у разі
успішного завершення, але є й винятки.

Код повернення останньої команди зберігається у спеціальній змінній `$?`.
Після виконання коду функції змінна `$?` зберігає код завершення останньої
команди, виконаної в функції. Таким чином у bash передається "значення,
повернуте" функцією. Після завершення роботи сценарію код повернення можна
отримати, звернувшись з командного рядка до змінної `$?`, тобто це буде
код повернення останньої команди, виконаної в сценарії.

Аналогічно ведуть себе функції, розташовані всередині сценарію, і сам
сценарій, повертаючи код завершення. Код, що повертається функцією або
сценарієм, визначається кодом повернення останньої команди. Команді `exit`
можна явно вказати код повернення у вигляді: `exit nnn`, де `nnn` — це код
повернення (число в діапазоні 0 - 255).

Коли робота сценарію завершується командою `exit` без параметрів, то код повернення сценарію визначається кодом повернення останньої виконаної команди.

### Конструкція створення циклів "for"

Розглянемо конструкцію "for". Ось стандартний приклад:

```bash
#!/bin/bash

for x in one two three four
do
    echo "number $x"
done
```

**Результат:**

```
number one
number two
number three
number four
```

Частина "for x" циклу "for" визначає змінну (яка називається ітератором) `$x`, яка послідовно приймає значення "one", "two", "three" і "four" (по одному за один такт циклу). Після присвоєння кожного нового значення змінній `$x` виконується тіло циклу (код між словами "do" і "done"). В тілі циклу виводиться значення змінної `$x`. Зверніть увагу, що після слова "in" у конструкції "for" завжди стоїть якийсь список. У цьому прикладі ми вказали чотири слова, але цей список може містити імена файлів або навіть шаблон (wildcard).

У наступному прикладі показано, як використовувати шаблони при ініціалізації ітератора циклу:

```bash
#!/bin/bash

for myfile in /etc/r*
do
    if [ -d "$myfile" ]
    then
      echo "$myfile (dir)"
    else
      echo "$myfile"
    fi
done
```

**Результат:**

```
/etc/rc0.d (dir)
/etc/rc1.d (dir)
/etc/rc2.d (dir)
/etc/rc3.d (dir)
/etc/rc4.d (dir)
/etc/rc5.d (dir)
/etc/rc6.d (dir)
/etc/rc.local
/etc/rcS.d (dir)
/etc/rearj.cfg
/etc/reportbug.conf
/etc/resolvconf (dir)
/etc/resolv.conf
/etc/rmt
/etc/rpc
/etc/rsyslog.conf
/etc/rsyslog.d (dir)
```

Код цього циклу виконається для кожного файлу з `/etc/`, ім'я якого починається з "r". Спочатку bash знайде всі такі файли і замінить шаблон на рядки `/etc/rc0.d`, `/etc/rc1.d`, `/etc/rc2.d` і так далі, перед тим як почати виконання циклу. В тілі циклу для кожного файлу з списку перевіряється, чи є цей файл директорією за допомогою оператора `-d`. Якщо файл виявився директорією, поряд з його назвою виводиться "(dir)".

У списку ініціалізації ітератора можна використовувати кілька шаблонів одночасно і навіть змінні оточення:

```bash
for x in /etc/r??? /var/lo* /home/drobbins/mystuff/* /tmp/${MYPATH}/*
do
    cp $x /mnt/mydira
done
```

Bash у цьому прикладі підставляє значення змінної та розкриває шаблони, а потім копіює всі файли у вказану директорію. У всіх попередніх прикладах були шаблони на основі абсолютних шляхів, але можна використовувати і відносні:

```bash
for x in ../* mystuff/*
do
     echo "$x is a silly file"
done
```

У цьому прикладі bash розкриває шаблон відносно поточної робочої директорії (не тієї, в якій знаходиться скрипт, а тієї, яку показує команда `pwd`). Пограйтеся з цим скриптом, запустіть його з різних директорій і подивіться на результат.

Іноді може знадобитися запустити цикл зі списком аргументів з командного рядка. Ось як це робиться:

```bash
#!/bin/bash

for i in "$@"
do
    echo "You wrote: ${i}."
done
```

**Результат:**

```bash
$ ./test.sh hello there you silly
You wrote: hello.
You wrote: there.
You wrote: you.
You wrote: silly.
```

У цьому прикладі ми використали змінну `$@`, значення якої дорівнює кількості аргументів, переданих скрипту.

### Арифметика в shell

Перед тим як перейти до розбору наступного виду циклічної конструкції, навчимося виконувати прості арифметичні операції за допомогою інтерпретатора. Просто заключте арифметичний вираз у конструкцію `$(( ))`, і bash обчислить його значення. Ось кілька прикладів:

```bash
$ echo $(( 100 / 3 ))
33
$ myvar="56"
$ echo $(( myvar + 12 ))
68
$ echo $(( myvar - myvar ))
0
$ myvar=$(( myvar + 1 ))
$ echo $myvar
57
```

Тепер розглянемо циклічні конструкції "while" і "until". "While" — цикл виконується, поки вираз у квадратних дужках істинний. Він має наступний формат:

```bash
while [ condition ]
do
    code
done
```

У наступному прикладі тіло циклу виконується точно 10 разів:

```bash
myvar=0
while [ $myvar -ne 10 ]
do
    echo "$myvar"
    myvar=$(( myvar + 1 ))
done
```

Після кожного виконання коду тіла циклу змінна `myvar` збільшується на 1. Коли значення змінної стає рівним 10, умова в квадратних дужках не виконується, і цикл завершується.

"Until" — цикл дуже схожий на "while" — цикл: він повторюється, поки вираз у квадратних дужках хибний. Ось приклад "until" — циклу, функціонально ідентичного "while" — циклу з попереднього прикладу:

```bash
myvar=0
until [ $myvar -eq 10 ]
do
    echo $myvar
    myvar=$(( myvar + 1 ))
done
```

#### Екстрений вихід з циклу

Для екстреного виходу з "for", "while" або "until" циклу використовується команда `break`. Для виходу з кількох вкладених циклів — `break N`, де N — кількість вкладених циклів.

```bash
name=0
while :
do
   wget http://example.com/gallery/${name}.png
   [ $? -ne 0 ] && break
done
```

У цьому прикладі: `while :` — безкінечний цикл. Двокрапка — це команда bash, яка нічого не робить, але завжди завершується успішно. Змінна `$?` містить статус, з яким завершилася остання команда (детальніше про спеціальні змінні описано в `man bash`). У нашому випадку код, відмінний від 0, означає, що під час завантаження файлу сталася помилка. Як тільки умова в квадратних дужках виконується, інтерпретатор переходить до виконання команди, що стоїть після логічного `і` (`&&`). `Break` перериває виконання циклу.

Передостанню стрічку попереднього прикладу можна замінити на умовну конструкцію `if`:

```bash
if [ $? -ne 0 ]
then
      break
fi
```

Або в один рядок:

```bash
if [ $? -ne 0 ]; then break; fi
```

Умовну конструкцію можна записувати в один рядок, лише потрібно поставити кілька розділових знаків `;`.

### Запуск Python скриптів

За аналогієї до параграфа про [Shell скрипти](#shell-скрипти)
python файли можна запускати як виконувані, вказавши в першому рядку
шлях до інтерпретатора:

```py
#!/usr/local/bin/python3
import time
import itertools

for i in itertools.count():
    print("Hello, World!", i)
    time.sleep(3)
```

і встановивши права доступу (передбачається, що файл було названо `script.py`)

```bash
chmod 750 ./script.py
```

Місце знаходження глобального інтерпретатора можна дізнатися, запустивши команду

```bash
$ which python3
/usr/local/bin/python3
```

або

```bash
$ whereis python3
/usr/local/bin/python3
/usr/bin/python3
```

Отже, python файл можна запустити прямо з поточної директорії:

```bash
$ ./script.py
```

## Таблиці команд

### bash

| Команда              | Опис                                                             | Опції                                                                                           |
| -------------------- | ---------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| `man <cmd>`          | Вивести довідку по команді `<cmd>`                               |                                                                                                 |
| `mkdir <name>`       | Створити папку з іменем `<name>`                                 |                                                                                                 |
| `cd [dir]`           | Перейти в папку `<dir>`. За замовчуванням — у домашню папку.     |                                                                                                 |
| `pwd`                | Виводить поточну папку                                           |                                                                                                 |
| `ls [dir]`           | Виводить вміст папки `<dir>`. За замовчуванням — поточної папки. | `-a` — показувати всі файли, <br> `-l` — довгий формат виводу, <br> `-h` — вивід у Kb, Mb тощо. |
| `cp <source> <dest>` | Копіювати файл `<source>` у `<dest>`                             | `-r` — для копіювання папок                                                                     |
| `rm <file>`          | Видалити файл `<file>`                                           | `-r` — для видалення папок                                                                      |
| `mv <source> <dest>` | Перемістити `<source>` у `<dest>`                                |                                                                                                 |
| `cat <file>`         | Вивести вміст файлу `<file>`                                     |                                                                                                 |
| `head <file>`        | Виводить перші 10 рядків файлу `<file>`                          | `-n <cnt>` — тільки `<cnt>` рядків                                                              |
| `tail <file>`        | Виводить останні 10 рядків файлу `<file>`                        | `-n <cnt>` — тільки `<cnt>` рядків                                                              |

### Клавіатура vim

| Команда            | Опис                                                   |
| ------------------ | ------------------------------------------------------ |
| `i`                | Перехід в режим вставки                                |
| `Esc` або `Ctrl+c` | Повернутися в командний режим                          |
| `u`                | Скасувати останнє дію                                  |
| `v`                | Перейти в режим виділення                              |
| `y`                | Копіювати                                              |
| `x`                | Вирізати                                               |
| `dd`               | Видалити рядок                                         |
| `yy`               | Копіювати рядок                                        |
| `p`                | Вставити                                               |
| `/`                | Пошук за регулярним виразом                            |
| `n [N]`            | Перейти до наступного [попереднього] результату пошуку |
| `:w`               | Зберегти зміни                                         |
| `:q`               | Вийти з редактора                                      |
| `:wq` або `ZZ`     | Зберегти зміни та вийти                                |

### Клавіатура nano

| Команда             | Опис                                    |
| ------------------- | --------------------------------------- |
| `Ctrl+O`            | Зберегти файл                           |
| `Ctrl+X`            | Вийти з редактора                       |
| `Ctrl+G`            | Відкрити довідку                        |
| `Ctrl+W`            | Пошук тексту                            |
| `Ctrl+K`            | Вирізати (видалити) рядок               |
| `Ctrl+U`            | Вставити рядок, який було вирізано      |
| `Ctrl+J`            | Вирівняти текст                         |
| `Ctrl+C`            | Показати позицію курсора                |
| `Ctrl+_`            | Перейти до рядка (ввести номер рядка)   |
| `Ctrl+A`            | Перейти на початок рядка                |
| `Ctrl+E`            | Перейти в кінець рядка                  |
| `Ctrl+T`            | Відкрити правопис (перевірка правопису) |
| `Ctrl+V`            | Прокрутити вниз (на одну сторінку)      |
| `Ctrl+Y`            | Прокрутити вгору (на одну сторінку)     |
| `Alt+6`             | Копіювати (виділити рядок)              |
| `Ctrl+X`, потім `Y` | Зберегти зміни та вийти                 |

## ✅ TODO

- [x] Закінчити запланований мінімум
- [x] Додати посилання до Змісту
- [ ] Виправити дрібні (і не дуже) друкарські помилки
